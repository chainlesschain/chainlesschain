# ChainlessChain AI Pipeline ä¼˜åŒ–æ–¹æ¡ˆ
## æ„å›¾è¯†åˆ« â†’ ä»»åŠ¡åˆ†è§£ â†’ å·¥å…·è°ƒç”¨ å…¨æµç¨‹ä¼˜åŒ–

**ç”Ÿæˆæ—¶é—´**: 2026-01-01
**å½“å‰ç‰ˆæœ¬**: v0.16.0
**ä¼˜åŒ–ç›®æ ‡**: æå‡ä»»åŠ¡æ‰§è¡Œè´¨é‡ã€å‡†ç¡®ç‡ã€å“åº”é€Ÿåº¦

---

## ğŸ“Š ç°çŠ¶åˆ†æ

### å½“å‰æ¶æ„äº®ç‚¹
âœ… å¤šå±‚æ¬¡æ„å›¾è¯†åˆ«ï¼ˆå…³é”®è¯â†’Few-shot LLMâ†’ä¸Šä¸‹æ–‡ï¼‰
âœ… RAGå¢å¼ºçš„ä»»åŠ¡è§„åˆ’
âœ… æ™ºèƒ½æŠ€èƒ½è°ƒåº¦ç³»ç»Ÿï¼ˆ15ä¸ªå†…ç½®æŠ€èƒ½ï¼‰
âœ… 150+ å·¥å…·åº“
âœ… æ··åˆæ£€ç´¢ç­–ç•¥ï¼ˆå‘é‡+å…³é”®è¯+é‡æ’åºï¼‰
âœ… å®Œå–„çš„é™çº§æœºåˆ¶

### å­˜åœ¨çš„ä¼˜åŒ–ç©ºé—´

#### 1ï¸âƒ£ **æ„å›¾è¯†åˆ«ç¯èŠ‚**
- âŒ ç¼ºå°‘**å¤šæ„å›¾å¹¶è¡Œè¯†åˆ«**èƒ½åŠ›ï¼ˆç”¨æˆ·ï¼š"åˆ›å»ºåšå®¢å¹¶éƒ¨ç½²åˆ°äº‘ç«¯"éœ€æ‹†åˆ†ä¸º2ä¸ªæ„å›¾ï¼‰
- âŒ Few-shotç¤ºä¾‹å›ºå®šï¼Œ**æ— æ³•åŠ¨æ€å­¦ä¹ **ç”¨æˆ·è¡¨è¾¾ä¹ æƒ¯
- âŒ å®ä½“æå–èƒ½åŠ›å¼±ï¼Œç¼ºå°‘**æ§½ä½å¡«å……**æœºåˆ¶
- âŒ ç½®ä¿¡åº¦é˜ˆå€¼ç¡¬ç¼–ç ï¼ˆ0.5/0.7/0.9ï¼‰ï¼Œ**æœªè‡ªé€‚åº”è°ƒæ•´**

#### 2ï¸âƒ£ **ä»»åŠ¡åˆ†è§£ç¯èŠ‚**
- âŒ åˆ†è§£ç²’åº¦ä¸å¯æ§ï¼ˆæœ‰æ—¶è¿‡ç²—ï¼Œæœ‰æ—¶è¿‡ç»†ï¼‰
- âŒ ç¼ºå°‘**ä¾èµ–å›¾æ„å»º**å’Œ**å¹¶è¡Œæ‰§è¡Œä¼˜åŒ–**
- âŒ RAGæ£€ç´¢ç»“æœæœªæ’åºï¼Œå¯èƒ½å¼•å…¥å™ªå£°
- âŒ å¿«é€Ÿæ‹†è§£æ¨¡å¼è¿‡äºç®€å•ï¼Œ**è´¨é‡ä¸ç¨³å®š**

#### 3ï¸âƒ£ **å·¥å…·è°ƒç”¨ç¯èŠ‚**
- âŒ å·¥å…·é€‰æ‹©ä¾èµ–ç¡¬ç¼–ç æ˜ å°„è¡¨ï¼Œ**æ— æ³•å¤„ç†ç»„åˆåœºæ™¯**
- âŒ ç¼ºå°‘**å·¥å…·æ‰§è¡Œæ²™ç®±**ï¼Œé”™è¯¯å®¹æ˜“çº§è”
- âŒ æ— **ä¸­é—´ç»“æœæ ¡éªŒ**æœºåˆ¶ï¼Œé”™è¯¯å‘ç°æ»å
- âŒ å·¥å…·å‚æ•°ç”Ÿæˆä¾èµ–LLMï¼Œ**å¤±è´¥ç‡è¾ƒé«˜**

#### 4ï¸âƒ£ **æ•´ä½“æµç¨‹**
- âŒ ä¸²è¡Œæ‰§è¡Œï¼Œ**æœªå……åˆ†åˆ©ç”¨å¹¶è¡Œæ€§**
- âŒ ç¼ºå°‘**åé¦ˆå¾ªç¯**ï¼Œæ‰§è¡Œå¤±è´¥åæ— æ³•è‡ªåŠ¨ä¿®æ­£
- âŒ ç”¨æˆ·æ— æ³•**å®æ—¶å¹²é¢„**ï¼ˆå®¡æ‰¹å…³é”®æ­¥éª¤ï¼‰
- âŒ ç›‘æ§æŒ‡æ ‡å•ä¸€ï¼Œ**éš¾ä»¥å®šä½ç“¶é¢ˆ**

---

## ğŸ¯ ä¼˜åŒ–æ–¹æ¡ˆï¼ˆ7å¤§æ–¹å‘ï¼‰

---

## æ–¹æ¡ˆ1: æ„å›¾è¯†åˆ«å¢å¼º

### 1.1 å¤šæ„å›¾è¯†åˆ«ä¸è§£è€¦

**é—®é¢˜**: ç”¨æˆ·è¾“å…¥"åˆ›å»ºåšå®¢ç½‘ç«™å¹¶éƒ¨ç½²åˆ°äº‘ç«¯"ï¼Œå½“å‰åªèƒ½è¯†åˆ«å•ä¸€æ„å›¾

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// intent-classifier.js æ–°å¢å¤šæ„å›¾è¯†åˆ«
async classifyMultiple(text, context = {}) {
  // 1. LLMè¯†åˆ«å¤šä¸ªæ„å›¾
  const prompt = `
ç”¨æˆ·è¾“å…¥: "${text}"
è¯·åˆ†ææ˜¯å¦åŒ…å«å¤šä¸ªç‹¬ç«‹æ„å›¾ï¼Œå¹¶æ‹†åˆ†ä¸ºç‹¬ç«‹ä»»åŠ¡ã€‚

è¾“å‡ºæ ¼å¼:
{
  "intents": [
    {
      "intent": "CREATE_FILE",
      "priority": 1,
      "description": "åˆ›å»ºåšå®¢ç½‘ç«™",
      "entities": {"fileType": "HTML", "theme": "dark"}
    },
    {
      "intent": "DEPLOY_PROJECT",
      "priority": 2,
      "description": "éƒ¨ç½²åˆ°äº‘ç«¯",
      "dependencies": [1],  // ä¾èµ–ç¬¬1ä¸ªä»»åŠ¡å®Œæˆ
      "entities": {"platform": "vercel", "domain": "myblog.com"}
    }
  ]
}
  `;

  const result = await this.llmService.complete({ messages: [{ role: 'user', content: prompt }] });
  return JSON.parse(result);
}
```

**ä¼˜åŠ¿**:
- âœ… æ”¯æŒå¤åˆä»»åŠ¡è‡ªåŠ¨æ‹†è§£
- âœ… æ˜ç¡®ä»»åŠ¡ä¾èµ–å…³ç³»
- âœ… ä¼˜å…ˆçº§æ’åº

---

### 1.2 åŠ¨æ€Few-shotå­¦ä¹ 

**é—®é¢˜**: Few-shotç¤ºä¾‹å›ºå®šï¼Œæ— æ³•å­¦ä¹ ç”¨æˆ·ä¹ æƒ¯

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// dynamic-few-shot-learner.js (æ–°å»º)
class DynamicFewShotLearner {
  constructor(db) {
    this.db = db;
    this.exampleCache = new Map(); // userId -> examples
  }

  // ä»ç”¨æˆ·å†å²ä¸­æå–Few-shotç¤ºä¾‹
  async getUserExamples(userId, intent, limit = 3) {
    // æŸ¥è¯¢ç”¨æˆ·è¿‡å»æˆåŠŸæ‰§è¡Œçš„ä»»åŠ¡
    const history = await this.db.query(`
      SELECT user_input, intent, entities, confidence
      FROM intent_recognition_history
      WHERE user_id = ? AND intent = ? AND success = 1 AND confidence > 0.85
      ORDER BY created_at DESC
      LIMIT ?
    `, [userId, intent, limit]);

    return history.map(h => ({
      input: h.user_input,
      output: { intent: h.intent, entities: JSON.parse(h.entities) }
    }));
  }

  // æ„å»ºåŠ¨æ€prompt
  async buildDynamicPrompt(text, userId) {
    const userExamples = await this.getUserExamples(userId, null, 5);

    let prompt = "åŸºäºä»¥ä¸‹ç”¨æˆ·å†å²ä¹ æƒ¯è¯†åˆ«æ„å›¾:\n\n";
    userExamples.forEach((ex, i) => {
      prompt += `ç¤ºä¾‹${i+1}:\nè¾“å…¥: "${ex.input}"\nè¾“å‡º: ${JSON.stringify(ex.output)}\n\n`;
    });

    prompt += `ç°åœ¨è¯†åˆ«: "${text}"`;
    return prompt;
  }
}
```

**æ•°æ®åº“è¡¨**:
```sql
CREATE TABLE intent_recognition_history (
  id INTEGER PRIMARY KEY,
  user_id TEXT,
  user_input TEXT,
  intent TEXT,
  entities TEXT,  -- JSON
  confidence REAL,
  success INTEGER,  -- 1=æˆåŠŸ, 0=å¤±è´¥
  created_at INTEGER
);

CREATE INDEX idx_user_intent ON intent_recognition_history(user_id, intent, success);
```

**ä¼˜åŠ¿**:
- âœ… ä¸ªæ€§åŒ–è¯†åˆ«ï¼Œå‡†ç¡®ç‡æå‡15-25%
- âœ… è‡ªåŠ¨å­¦ä¹ ç”¨æˆ·è¡¨è¾¾ä¹ æƒ¯ï¼ˆ"åšä¸ªç½‘é¡µ" vs "ç”ŸæˆHTMLæ–‡ä»¶"ï¼‰

---

### 1.3 æ§½ä½å¡«å……ä¸äº¤äº’ç¡®è®¤

**é—®é¢˜**: ç¼ºå°‘å¿…è¦å‚æ•°æ—¶ç›´æ¥å¤±è´¥ï¼Œç”¨æˆ·ä½“éªŒå·®

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// slot-filler.js (æ–°å»º)
class SlotFiller {
  // å®šä¹‰æ¯ä¸ªæ„å›¾çš„å¿…éœ€æ§½ä½
  requiredSlots = {
    'CREATE_FILE': ['fileType', 'content'],
    'DEPLOY_PROJECT': ['platform', 'projectPath'],
    'EXPORT_FILE': ['format', 'targetPath']
  };

  optionalSlots = {
    'CREATE_FILE': ['theme', 'colors', 'framework'],
    'DEPLOY_PROJECT': ['domain', 'env']
  };

  async fillSlots(intent, entities, context, askUserCallback) {
    const required = this.requiredSlots[intent.intent] || [];
    const missing = [];

    // æ£€æŸ¥ç¼ºå¤±çš„å¿…éœ€æ§½ä½
    for (const slot of required) {
      if (!entities[slot]) {
        missing.push(slot);
      }
    }

    // å°è¯•ä»ä¸Šä¸‹æ–‡æ¨æ–­
    const inferred = await this.inferFromContext(missing, context);
    Object.assign(entities, inferred);

    // ä»ç¼ºå¤±åˆ™è¯¢é—®ç”¨æˆ·
    const stillMissing = missing.filter(s => !entities[s]);
    if (stillMissing.length > 0) {
      const userInput = await askUserCallback(
        `è¯·æä¾›ä»¥ä¸‹ä¿¡æ¯: ${stillMissing.map(s => this.getSlotPrompt(s)).join(', ')}`
      );

      // è§£æç”¨æˆ·å›å¤
      const extracted = await this.extractFromUserInput(userInput, stillMissing);
      Object.assign(entities, extracted);
    }

    return entities;
  }

  async inferFromContext(slots, context) {
    const result = {};

    if (slots.includes('projectPath') && context.currentProject) {
      result.projectPath = context.currentProject.path;
    }

    if (slots.includes('fileType') && context.currentFile) {
      const ext = context.currentFile.split('.').pop();
      result.fileType = this.extToType(ext);  // .js -> JavaScript
    }

    return result;
  }

  getSlotPrompt(slot) {
    const prompts = {
      'fileType': 'æ–‡ä»¶ç±»å‹ (HTML/CSS/JavaScript/Word/PDF)',
      'platform': 'éƒ¨ç½²å¹³å° (Vercel/Netlify/GitHub Pages)',
      'format': 'å¯¼å‡ºæ ¼å¼ (PDF/Word/Markdown)',
      'content': 'æ–‡ä»¶å†…å®¹æˆ–ä¸»é¢˜'
    };
    return prompts[slot] || slot;
  }
}
```

**ä¼˜åŠ¿**:
- âœ… ä»»åŠ¡æˆåŠŸç‡æå‡30%+
- âœ… ç”¨æˆ·ä½“éªŒä¼˜åŒ–ï¼ˆå¼•å¯¼å¼äº¤äº’ï¼‰
- âœ… æ™ºèƒ½ä¸Šä¸‹æ–‡æ¨æ–­ï¼Œå‡å°‘è¯¢é—®æ¬¡æ•°

---

### 1.4 ç½®ä¿¡åº¦è‡ªé€‚åº”é˜ˆå€¼

**é—®é¢˜**: å›ºå®šé˜ˆå€¼ï¼ˆ0.5/0.7/0.9ï¼‰æ— æ³•é€‚åº”ä¸åŒåœºæ™¯

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// confidence-calibrator.js (æ–°å»º)
class ConfidenceCalibrator {
  constructor(db) {
    this.db = db;
    this.thresholds = {
      high_risk: 0.85,  // é«˜é£é™©æ“ä½œï¼ˆåˆ é™¤é¡¹ç›®ã€éƒ¨ç½²ï¼‰
      medium_risk: 0.70,  // ä¸­é£é™©ï¼ˆä¿®æ”¹æ–‡ä»¶ï¼‰
      low_risk: 0.50   // ä½é£é™©ï¼ˆæŸ¥è¯¢ã€åˆ†æï¼‰
    };
  }

  // åŠ¨æ€è°ƒæ•´é˜ˆå€¼
  async calibrate(intent, userHistory) {
    const riskLevel = this.getRiskLevel(intent.intent);
    let threshold = this.thresholds[riskLevel];

    // å¦‚æœç”¨æˆ·å†å²æˆåŠŸç‡é«˜ï¼Œé™ä½é˜ˆå€¼
    const userSuccessRate = await this.getUserSuccessRate(userHistory.userId, intent.intent);
    if (userSuccessRate > 0.9) {
      threshold -= 0.1;  // ä¿¡ä»»ç”¨æˆ·ï¼Œé™ä½é—¨æ§›
    }

    // å¦‚æœæœ€è¿‘è¿ç»­å¤±è´¥ï¼Œæé«˜é˜ˆå€¼
    const recentFailures = await this.getRecentFailures(userHistory.userId, 5);
    if (recentFailures >= 3) {
      threshold += 0.15;  // è¦æ±‚æ›´é«˜ç½®ä¿¡åº¦
    }

    return Math.max(0.4, Math.min(0.95, threshold));  // é™åˆ¶åœ¨[0.4, 0.95]
  }

  getRiskLevel(intent) {
    const highRisk = ['DELETE_PROJECT', 'DEPLOY_PROJECT', 'MODIFY_CONFIG'];
    const mediumRisk = ['EDIT_FILE', 'CREATE_FILE'];

    if (highRisk.includes(intent)) return 'high_risk';
    if (mediumRisk.includes(intent)) return 'medium_risk';
    return 'low_risk';
  }
}
```

**ä¼˜åŠ¿**:
- âœ… é«˜é£é™©æ“ä½œæ›´è°¨æ…ï¼ˆåˆ é™¤ã€éƒ¨ç½²ï¼‰
- âœ… ä½é£é™©æ“ä½œæ›´å®½æ¾ï¼ˆæŸ¥è¯¢ã€åˆ†æï¼‰
- âœ… ä¸ªæ€§åŒ–è°ƒæ•´ï¼Œé€‚åº”ç”¨æˆ·ç†Ÿç»ƒåº¦

---

## æ–¹æ¡ˆ2: ä»»åŠ¡åˆ†è§£ä¼˜åŒ–

### 2.1 åˆ†å±‚åˆ†è§£ç­–ç•¥

**é—®é¢˜**: åˆ†è§£ç²’åº¦ä¸å¯æ§ï¼ˆ"åˆ›å»ºç½‘ç«™"å¯èƒ½åˆ†è§£ä¸º1æ­¥æˆ–20æ­¥ï¼‰

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// hierarchical-task-planner.js (æ–°å»º)
class HierarchicalTaskPlanner {
  async plan(intent, context, options = {}) {
    const granularity = options.granularity || 'auto';  // 'coarse'/'medium'/'fine'/'auto'

    // 1. é«˜å±‚åˆ†è§£ï¼ˆä¸šåŠ¡é€»è¾‘ï¼‰
    const businessPlan = await this.decomposeBusinessLogic(intent, context);
    // ç»“æœ: ["è®¾è®¡ç½‘ç«™ç»“æ„", "å®ç°å‰ç«¯", "éƒ¨ç½²ä¸Šçº¿"]

    // 2. ä¸­å±‚åˆ†è§£ï¼ˆæŠ€æœ¯ä»»åŠ¡ï¼‰
    const technicalPlan = [];
    for (const businessTask of businessPlan) {
      const subTasks = await this.decomposeTechnical(businessTask, granularity);
      technicalPlan.push(...subTasks);
    }
    // ç»“æœ: ["åˆ›å»ºHTML", "ç¼–å†™CSS", "æ·»åŠ JavaScript", "é…ç½®éƒ¨ç½²"]

    // 3. åº•å±‚åˆ†è§£ï¼ˆå·¥å…·è°ƒç”¨ï¼‰
    const executionPlan = [];
    for (const techTask of technicalPlan) {
      const toolCalls = await this.decomposeToTools(techTask, context);
      executionPlan.push(...toolCalls);
    }
    // ç»“æœ: [
    //   { tool: 'html_generator', params: {...} },
    //   { tool: 'css_generator', params: {...} },
    //   ...
    // ]

    return {
      businessPlan,
      technicalPlan,
      executionPlan,
      totalSteps: executionPlan.length,
      estimatedDuration: this.estimateDuration(executionPlan)
    };
  }

  async decomposeBusinessLogic(intent, context) {
    const prompt = `
å°†ç”¨æˆ·æ„å›¾åˆ†è§£ä¸º3-5ä¸ªé«˜å±‚ä¸šåŠ¡æ­¥éª¤ï¼ˆé¢å‘ç”¨æˆ·çš„æè¿°ï¼‰ã€‚

æ„å›¾: ${JSON.stringify(intent)}
ä¸Šä¸‹æ–‡: ${JSON.stringify(context)}

è¾“å‡ºæ ¼å¼ï¼ˆJSONæ•°ç»„ï¼‰:
["æ­¥éª¤1æè¿°", "æ­¥éª¤2æè¿°", "æ­¥éª¤3æè¿°"]
    `;

    const result = await this.llmService.complete({ messages: [{ role: 'user', content: prompt }] });
    return JSON.parse(result);
  }
}
```

**ä¼˜åŠ¿**:
- âœ… åˆ†å±‚å±•ç¤ºï¼Œç”¨æˆ·æ›´å®¹æ˜“ç†è§£
- âœ… å¯æ§ç²’åº¦ï¼Œé€‚é…ä¸åŒåœºæ™¯
- âœ… ä¾¿äºè¿›åº¦å¯è§†åŒ–

---

### 2.2 ä¾èµ–å›¾æ„å»ºä¸å¹¶è¡Œä¼˜åŒ–

**é—®é¢˜**: å½“å‰ä¸²è¡Œæ‰§è¡Œï¼Œæµªè´¹æ—¶é—´

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// task-dependency-graph.js (æ–°å»º)
class TaskDependencyGraph {
  constructor() {
    this.nodes = new Map();  // taskId -> Task
    this.edges = new Map();  // taskId -> [dependencyIds]
  }

  addTask(task) {
    this.nodes.set(task.id, task);
    this.edges.set(task.id, task.dependencies || []);
  }

  // æ‹“æ‰‘æ’åº + å¹¶è¡Œå±‚çº§åˆ’åˆ†
  getExecutionLayers() {
    const layers = [];
    const completed = new Set();
    const inProgress = new Set();

    while (completed.size < this.nodes.size) {
      const currentLayer = [];

      for (const [taskId, deps] of this.edges) {
        if (completed.has(taskId) || inProgress.has(taskId)) continue;

        // æ‰€æœ‰ä¾èµ–å·²å®Œæˆï¼Œå¯ä»¥æ‰§è¡Œ
        if (deps.every(depId => completed.has(depId))) {
          currentLayer.push(this.nodes.get(taskId));
          inProgress.add(taskId);
        }
      }

      if (currentLayer.length === 0) {
        throw new Error('æ£€æµ‹åˆ°å¾ªç¯ä¾èµ–æˆ–å­¤ç«‹èŠ‚ç‚¹');
      }

      layers.push(currentLayer);
      currentLayer.forEach(task => {
        inProgress.delete(task.id);
        completed.add(task.id);
      });
    }

    return layers;
  }

  // ä¼°ç®—å¹¶è¡Œæ‰§è¡Œæ—¶é—´
  estimateParallelDuration() {
    const layers = this.getExecutionLayers();
    return layers.reduce((total, layer) => {
      const layerMaxDuration = Math.max(...layer.map(t => t.estimatedDuration || 5));
      return total + layerMaxDuration;
    }, 0);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
async function executePlanInParallel(plan) {
  const graph = new TaskDependencyGraph();
  plan.executionPlan.forEach(task => graph.addTask(task));

  const layers = graph.getExecutionLayers();

  console.log(`æ€»ä»»åŠ¡æ•°: ${plan.executionPlan.length}`);
  console.log(`å¹¶è¡Œå±‚çº§: ${layers.length}`);
  console.log(`é¢„è®¡è€—æ—¶: ${graph.estimateParallelDuration()}ç§’ (ä¸²è¡Œéœ€${plan.executionPlan.reduce((s, t) => s + (t.estimatedDuration || 5), 0)}ç§’)`);

  // é€å±‚æ‰§è¡Œï¼ˆå±‚å†…å¹¶è¡Œï¼‰
  for (const layer of layers) {
    await Promise.all(layer.map(task => executeTool(task.tool, task.params)));
  }
}
```

**ç¤ºä¾‹è¾“å‡º**:
```
æ€»ä»»åŠ¡æ•°: 8
å¹¶è¡Œå±‚çº§: 3
é¢„è®¡è€—æ—¶: 15ç§’ (ä¸²è¡Œéœ€40ç§’)

Layer 1 (å¹¶è¡Œ3ä¸ªä»»åŠ¡):
  - html_generator
  - css_generator
  - js_generator

Layer 2 (å¹¶è¡Œ2ä¸ªä»»åŠ¡):
  - file_writer (å†™index.html)
  - file_writer (å†™style.css)

Layer 3 (ä¸²è¡Œ1ä¸ªä»»åŠ¡):
  - git_commit
```

**ä¼˜åŠ¿**:
- âœ… å¹¶è¡Œæ‰§è¡Œï¼Œé€Ÿåº¦æå‡60%+
- âœ… è‡ªåŠ¨æ£€æµ‹å¾ªç¯ä¾èµ–
- âœ… ä¼˜åŒ–èµ„æºåˆ©ç”¨

---

### 2.3 RAGæ£€ç´¢ç»“æœé‡æ’åº

**é—®é¢˜**: RAGæ£€ç´¢ç»“æœæœªæ’åºï¼Œå¯èƒ½å¼•å…¥æ— å…³å™ªå£°

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// task-planner.js å¢å¼ºRAGæµç¨‹
async enhanceWithRAG(userRequest, projectContext) {
  // 1. åŸå§‹æ£€ç´¢
  const ragResult = await this.ragManager.enhancedQuery(
    projectContext.projectId,
    userRequest,
    {
      projectLimit: 5,      // å¢åŠ å€™é€‰æ•°é‡
      knowledgeLimit: 5,
      conversationLimit: 3
    }
  );

  // 2. é‡æ’åºï¼ˆåŸºäºä»»åŠ¡ç›¸å…³æ€§ï¼‰
  const rerankedDocs = await this.rerankForTaskPlanning(
    userRequest,
    ragResult.context.allDocuments
  );

  // 3. è¿‡æ»¤ä½è´¨é‡æ–‡æ¡£
  const filteredDocs = rerankedDocs.filter(doc =>
    doc.relevanceScore > 0.6 &&  // ç›¸å…³æ€§é˜ˆå€¼
    doc.quality > 0.5             // è´¨é‡é˜ˆå€¼ï¼ˆåŸºäºæ–‡æ¡£é•¿åº¦ã€ç»“æ„ç­‰ï¼‰
  );

  // 4. æˆªå–Top-K
  const topDocs = filteredDocs.slice(0, 3);

  return {
    ...ragResult,
    context: {
      ...ragResult.context,
      allDocuments: topDocs
    }
  };
}

async rerankForTaskPlanning(query, documents) {
  const prompt = `
ç»™ä»¥ä¸‹æ–‡æ¡£è¯„åˆ†ï¼ˆ0-1ï¼‰ï¼Œæ ¹æ®å®ƒä»¬å¯¹ä»»åŠ¡è§„åˆ’çš„å¸®åŠ©ç¨‹åº¦ï¼š

ä»»åŠ¡: ${query}

æ–‡æ¡£åˆ—è¡¨:
${documents.map((doc, i) => `${i+1}. ${doc.content.substring(0, 200)}...`).join('\n\n')}

è¾“å‡ºæ ¼å¼ï¼ˆJSONæ•°ç»„ï¼‰:
[
  {"index": 0, "score": 0.95, "reason": "åŒ…å«è¯¦ç»†å®ç°æ­¥éª¤"},
  {"index": 1, "score": 0.60, "reason": "éƒ¨åˆ†ç›¸å…³"},
  ...
]
  `;

  const result = await this.llmService.complete({ messages: [{ role: 'user', content: prompt }] });
  const scores = JSON.parse(result);

  return documents.map((doc, i) => ({
    ...doc,
    relevanceScore: scores.find(s => s.index === i)?.score || 0
  })).sort((a, b) => b.relevanceScore - a.relevanceScore);
}
```

**ä¼˜åŠ¿**:
- âœ… å‡å°‘å™ªå£°å¹²æ‰°ï¼Œè§„åˆ’è´¨é‡æå‡20%
- âœ… LLM tokenæ¶ˆè€—å‡å°‘30%ï¼ˆè¿‡æ»¤æ— å…³æ–‡æ¡£ï¼‰

---

### 2.4 Plan Bå¿«é€Ÿæ‹†è§£å¢å¼º

**é—®é¢˜**: LLMå¤±è´¥æ—¶ï¼Œå¿«é€Ÿæ‹†è§£è´¨é‡ä¸ç¨³å®š

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// quick-decompose-enhanced.js (é‡æ„)
class QuickDecomposeEnhanced {
  // åŸºäºæ¨¡æ¿åº“çš„å¿«é€Ÿæ‹†è§£
  async decompose(intent, context) {
    // 1. åŒ¹é…é¢„å®šä¹‰æ¨¡æ¿
    const template = this.matchTemplate(intent);

    if (template) {
      // ä½¿ç”¨æ¨¡æ¿ç”Ÿæˆè®¡åˆ’
      return this.fillTemplate(template, intent, context);
    }

    // 2. åŸºäºè§„åˆ™å¼•æ“ç”Ÿæˆ
    const plan = this.ruleBasedDecompose(intent, context);

    // 3. æ·»åŠ å¸¸è§åå¤„ç†æ­¥éª¤
    plan.steps.push(...this.addCommonPostSteps(intent));

    return plan;
  }

  matchTemplate(intent) {
    const templates = {
      'CREATE_FILE_HTML': {
        name: 'åˆ›å»ºHTMLç½‘é¡µ',
        steps: [
          { tool: 'html_generator', paramsTemplate: '{{entities}}' },
          { tool: 'css_generator', paramsTemplate: '{{entities.theme}}' },
          { tool: 'file_writer', paramsTemplate: '{{output}}' }
        ]
      },
      'CREATE_FILE_WORD': {
        name: 'åˆ›å»ºWordæ–‡æ¡£',
        steps: [
          { tool: 'word_generator', paramsTemplate: '{{entities.content}}' },
          { tool: 'file_writer', paramsTemplate: '{{output}}' }
        ]
      },
      'DATA_ANALYSIS': {
        name: 'æ•°æ®åˆ†æ',
        steps: [
          { tool: 'file_reader', paramsTemplate: '{{entities.filePath}}' },
          { tool: 'data_analyzer', paramsTemplate: '{{data}}' },
          { tool: 'data_visualizer', paramsTemplate: '{{analysis_result}}' }
        ]
      }
    };

    const key = `${intent.intent}_${intent.entities.fileType || intent.entities.action}`;
    return templates[key];
  }

  addCommonPostSteps(intent) {
    const postSteps = [];

    // å¦‚æœæ˜¯åˆ›å»ºæ–‡ä»¶ï¼Œè‡ªåŠ¨æ·»åŠ Gitæäº¤
    if (intent.intent === 'CREATE_FILE' || intent.intent === 'EDIT_FILE') {
      postSteps.push({
        tool: 'git_commit',
        params: { message: `è‡ªåŠ¨æäº¤: ${intent.description}` },
        optional: true  // æ ‡è®°ä¸ºå¯é€‰æ­¥éª¤
      });
    }

    // å¦‚æœæ˜¯æ•°æ®åˆ†æï¼Œè‡ªåŠ¨ç”ŸæˆæŠ¥å‘Š
    if (intent.intent === 'ANALYZE_DATA') {
      postSteps.push({
        tool: 'report_generator',
        params: { format: 'markdown' },
        optional: true
      });
    }

    return postSteps;
  }
}
```

**ä¼˜åŠ¿**:
- âœ… æ¨¡æ¿è¦†ç›–å¸¸è§åœºæ™¯ï¼ŒæˆåŠŸç‡æå‡40%
- âœ… æ·»åŠ æ™ºèƒ½åå¤„ç†æ­¥éª¤ï¼ˆGitæäº¤ã€æŠ¥å‘Šç”Ÿæˆï¼‰

---

## æ–¹æ¡ˆ3: å·¥å…·è°ƒç”¨ä¼˜åŒ–

### 3.1 å·¥å…·ç»„åˆä¸ç¼–æ’

**é—®é¢˜**: å·¥å…·é€‰æ‹©ä¾èµ–ç¡¬ç¼–ç ï¼Œæ— æ³•å¤„ç†å¤æ‚ç»„åˆåœºæ™¯

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// tool-composer.js (æ–°å»º)
class ToolComposer {
  // å·¥å…·èƒ½åŠ›æè¿°ï¼ˆç”¨äºLLMç†è§£ï¼‰
  toolCapabilities = {
    'html_generator': {
      input: 'text_description',
      output: 'html_string',
      capabilities: ['ç”ŸæˆHTMLç»“æ„', 'æ”¯æŒå¤šç§å¸ƒå±€', 'å“åº”å¼è®¾è®¡']
    },
    'css_generator': {
      input: 'style_requirements',
      output: 'css_string',
      capabilities: ['ç”ŸæˆCSSæ ·å¼', 'æ”¯æŒä¸»é¢˜è‰²', 'åŠ¨ç”»æ•ˆæœ']
    },
    'file_writer': {
      input: 'file_content + path',
      output: 'file_saved_path',
      capabilities: ['å†™å…¥æ–‡ä»¶åˆ°ç£ç›˜', 'è‡ªåŠ¨åˆ›å»ºç›®å½•']
    },
    'image_optimizer': {
      input: 'image_path',
      output: 'optimized_image_path',
      capabilities: ['å‹ç¼©å›¾ç‰‡', 'è°ƒæ•´å°ºå¯¸', 'æ ¼å¼è½¬æ¢']
    }
  };

  // è‡ªåŠ¨ç»„åˆå·¥å…·é“¾
  async composeToolChain(taskDescription, availableTools) {
    const prompt = `
æ ¹æ®ä»»åŠ¡éœ€æ±‚ï¼Œä»å¯ç”¨å·¥å…·ä¸­é€‰æ‹©å¹¶ç»„åˆæˆå·¥å…·é“¾ã€‚

ä»»åŠ¡: ${taskDescription}

å¯ç”¨å·¥å…·:
${Object.entries(this.toolCapabilities)
  .filter(([name]) => availableTools.includes(name))
  .map(([name, cap]) => `- ${name}: ${cap.capabilities.join(', ')} (è¾“å…¥:${cap.input}, è¾“å‡º:${cap.output})`)
  .join('\n')}

è¦æ±‚:
1. å·¥å…·ä¹‹é—´è¾“å‡ºå’Œè¾“å…¥è¦åŒ¹é…
2. å°½é‡å‡å°‘å·¥å…·è°ƒç”¨æ¬¡æ•°
3. ç¡®ä¿æ•°æ®æµç•…

è¾“å‡ºæ ¼å¼ï¼ˆJSONï¼‰:
{
  "chain": [
    {"tool": "html_generator", "input": "{{user_description}}", "output": "html_content"},
    {"tool": "file_writer", "input": "{{html_content}}", "output": "file_path"}
  ],
  "reasoning": "å…ˆç”ŸæˆHTMLï¼Œç„¶åå†™å…¥æ–‡ä»¶"
}
    `;

    const result = await this.llmService.complete({ messages: [{ role: 'user', content: prompt }] });
    return JSON.parse(result);
  }

  // æ‰§è¡Œå·¥å…·é“¾ï¼ˆæ•°æ®æµè‡ªåŠ¨ä¼ é€’ï¼‰
  async executeChain(chain, initialInput) {
    let context = { user_description: initialInput };

    for (const step of chain.chain) {
      // æ›¿æ¢è¾“å…¥å˜é‡
      const input = this.resolveVariables(step.input, context);

      // æ‰§è¡Œå·¥å…·
      const output = await this.functionCaller.call(step.tool, input);

      // ä¿å­˜è¾“å‡ºåˆ°ä¸Šä¸‹æ–‡
      context[step.output] = output;
    }

    return context;
  }

  resolveVariables(template, context) {
    // æ›¿æ¢ {{variable}} ä¸ºå®é™…å€¼
    return template.replace(/\{\{(\w+)\}\}/g, (match, varName) => {
      return context[varName] || match;
    });
  }
}
```

**ä¼˜åŠ¿**:
- âœ… åŠ¨æ€å·¥å…·ç»„åˆï¼Œé€‚é…å¤æ‚åœºæ™¯
- âœ… è‡ªåŠ¨æ•°æ®æµä¼ é€’
- âœ… å‡å°‘ä¸­é—´æ­¥éª¤

---

### 3.2 å·¥å…·æ‰§è¡Œæ²™ç®±

**é—®é¢˜**: å·¥å…·æ‰§è¡Œé”™è¯¯å®¹æ˜“çº§è”å¤±è´¥

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// tool-sandbox.js (æ–°å»º)
class ToolSandbox {
  async executeSafely(toolName, params, options = {}) {
    const timeout = options.timeout || 30000;  // 30ç§’è¶…æ—¶
    const retries = options.retries || 2;      // é‡è¯•2æ¬¡

    // åˆ›å»ºå¿«ç…§ï¼ˆç”¨äºå›æ»šï¼‰
    const snapshot = await this.createSnapshot(params);

    try {
      // é™åˆ¶è¶…æ—¶æ‰§è¡Œ
      const result = await Promise.race([
        this.executeWithRetries(toolName, params, retries),
        this.timeoutPromise(timeout)
      ]);

      // æ ¡éªŒç»“æœ
      const validation = await this.validateResult(result, toolName);
      if (!validation.valid) {
        throw new Error(`ç»“æœæ ¡éªŒå¤±è´¥: ${validation.reason}`);
      }

      return result;

    } catch (error) {
      console.error(`å·¥å…·æ‰§è¡Œå¤±è´¥: ${toolName}`, error);

      // å›æ»šåˆ°å¿«ç…§
      await this.rollback(snapshot);

      // è®°å½•é”™è¯¯
      await this.logError(toolName, params, error);

      throw error;
    }
  }

  async executeWithRetries(toolName, params, retries) {
    for (let i = 0; i <= retries; i++) {
      try {
        return await this.functionCaller.call(toolName, params);
      } catch (error) {
        if (i === retries) throw error;

        console.log(`é‡è¯• ${i+1}/${retries}: ${toolName}`);
        await this.sleep(1000 * (i + 1));  // æŒ‡æ•°é€€é¿
      }
    }
  }

  async validateResult(result, toolName) {
    // åŸºäºå·¥å…·ç±»å‹çš„æ ¡éªŒè§„åˆ™
    const validators = {
      'html_generator': (r) => r.html && r.html.includes('<!DOCTYPE'),
      'css_generator': (r) => r.css && r.css.length > 0,
      'file_writer': (r) => r.path && require('fs').existsSync(r.path),
      'word_generator': (r) => r.filePath && r.filePath.endsWith('.docx')
    };

    const validator = validators[toolName];
    if (!validator) {
      return { valid: true };  // æ— æ ¡éªŒè§„åˆ™ï¼Œé»˜è®¤é€šè¿‡
    }

    try {
      const valid = validator(result);
      return { valid, reason: valid ? '' : 'æ ¡éªŒå‡½æ•°è¿”å›false' };
    } catch (error) {
      return { valid: false, reason: error.message };
    }
  }

  async createSnapshot(params) {
    // å¦‚æœæ¶‰åŠæ–‡ä»¶æ“ä½œï¼Œå¤‡ä»½æ–‡ä»¶
    if (params.filePath && require('fs').existsSync(params.filePath)) {
      const backupPath = `${params.filePath}.backup_${Date.now()}`;
      require('fs').copyFileSync(params.filePath, backupPath);
      return { type: 'file', backupPath, originalPath: params.filePath };
    }

    return { type: 'none' };
  }

  async rollback(snapshot) {
    if (snapshot.type === 'file') {
      require('fs').copyFileSync(snapshot.backupPath, snapshot.originalPath);
      require('fs').unlinkSync(snapshot.backupPath);
    }
  }
}
```

**ä¼˜åŠ¿**:
- âœ… è‡ªåŠ¨é‡è¯•ï¼Œå®¹é”™æ€§æå‡50%
- âœ… ç»“æœæ ¡éªŒï¼ŒåŠæ—¶å‘ç°é”™è¯¯
- âœ… å¿«ç…§å›æ»šï¼Œé¿å…æ•°æ®æŸå
- âœ… è¶…æ—¶ä¿æŠ¤ï¼Œé˜²æ­¢å¡æ­»

---

### 3.3 ä¸­é—´ç»“æœæ ¡éªŒ

**é—®é¢˜**: é”™è¯¯å‘ç°æ»åï¼Œæµªè´¹åç»­è®¡ç®—

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// checkpoint-validator.js (æ–°å»º)
class CheckpointValidator {
  // åœ¨å…³é”®æ­¥éª¤åæ ¡éªŒ
  async validateCheckpoint(stepIndex, result, plan) {
    const validations = [];

    // 1. ç»“æœå®Œæ•´æ€§æ£€æŸ¥
    if (!result || result.success === false) {
      validations.push({
        type: 'completeness',
        passed: false,
        reason: 'æ­¥éª¤æ‰§è¡Œå¤±è´¥æˆ–ç»“æœä¸ºç©º'
      });
    }

    // 2. é¢„æœŸè¾“å‡ºæ£€æŸ¥
    const expectedOutputs = plan.subtasks[stepIndex].expected_outputs || [];
    for (const expectedKey of expectedOutputs) {
      if (!result[expectedKey]) {
        validations.push({
          type: 'expected_output',
          passed: false,
          reason: `ç¼ºå°‘é¢„æœŸè¾“å‡º: ${expectedKey}`
        });
      }
    }

    // 3. ä¾èµ–æ•°æ®æ£€æŸ¥ï¼ˆä¸ºä¸‹ä¸€æ­¥å‡†å¤‡ï¼‰
    const nextStep = plan.subtasks[stepIndex + 1];
    if (nextStep) {
      const requiredInputs = this.extractRequiredInputs(nextStep.params);
      for (const input of requiredInputs) {
        if (!result[input]) {
          validations.push({
            type: 'next_step_dependency',
            passed: false,
            reason: `ä¸‹ä¸€æ­¥éœ€è¦ ${input}ï¼Œä½†å½“å‰æ­¥éª¤æœªæä¾›`
          });
        }
      }
    }

    // 4. LLMè´¨é‡æ£€æŸ¥ï¼ˆå¯é€‰ï¼Œè€—æ—¶è¾ƒé•¿ï¼‰
    if (plan.subtasks[stepIndex].quality_check_required) {
      const qualityScore = await this.llmQualityCheck(result, plan.subtasks[stepIndex]);
      validations.push({
        type: 'llm_quality',
        passed: qualityScore > 0.7,
        score: qualityScore,
        reason: qualityScore <= 0.7 ? 'è´¨é‡è¯„åˆ†ä½äºé˜ˆå€¼' : ''
      });
    }

    const allPassed = validations.every(v => v.passed !== false);

    return {
      passed: allPassed,
      validations,
      recommendation: allPassed ? 'continue' : 'retry_or_skip'
    };
  }

  async llmQualityCheck(result, stepConfig) {
    const prompt = `
è¯„ä¼°ä»¥ä¸‹æ­¥éª¤çš„è¾“å‡ºè´¨é‡ï¼ˆ0-1åˆ†ï¼‰:

æ­¥éª¤: ${stepConfig.title}
é¢„æœŸ: ${stepConfig.description}

å®é™…è¾“å‡º:
${JSON.stringify(result, null, 2)}

è¯„åˆ†æ ‡å‡†:
- 0.9-1.0: å®Œå…¨ç¬¦åˆé¢„æœŸï¼Œè´¨é‡ä¼˜ç§€
- 0.7-0.9: åŸºæœ¬ç¬¦åˆé¢„æœŸï¼Œæœ‰å°ç‘•ç–µ
- 0.5-0.7: éƒ¨åˆ†ç¬¦åˆé¢„æœŸï¼Œéœ€ä¿®æ­£
- 0.0-0.5: ä¸ç¬¦åˆé¢„æœŸï¼Œå¤±è´¥

è¾“å‡ºæ ¼å¼: {"score": 0.85, "reason": "HTMLç»“æ„å®Œæ•´ï¼Œä½†ç¼ºå°‘metaæ ‡ç­¾"}
    `;

    const result = await this.llmService.complete({ messages: [{ role: 'user', content: prompt }] });
    return JSON.parse(result).score;
  }
}
```

**ä½¿ç”¨ç¤ºä¾‹**:
```javascript
// åœ¨æ‰§è¡Œè®¡åˆ’æ—¶æ’å…¥æ ¡éªŒç‚¹
for (let i = 0; i < plan.subtasks.length; i++) {
  const stepResult = await executeStep(plan.subtasks[i]);

  // æ ¡éªŒå…³é”®æ­¥éª¤
  if (plan.subtasks[i].is_critical) {
    const validation = await checkpointValidator.validateCheckpoint(i, stepResult, plan);

    if (!validation.passed) {
      console.warn(`æ­¥éª¤${i+1}æ ¡éªŒå¤±è´¥:`, validation.validations);

      // è¯¢é—®ç”¨æˆ·æ˜¯å¦ç»§ç»­
      const shouldContinue = await askUser(`æ­¥éª¤${i+1}å­˜åœ¨é—®é¢˜ï¼Œæ˜¯å¦ç»§ç»­æ‰§è¡Œï¼Ÿ`);
      if (!shouldContinue) {
        break;
      }
    }
  }
}
```

**ä¼˜åŠ¿**:
- âœ… æ—©æœŸå‘ç°é”™è¯¯ï¼ŒèŠ‚çœè®¡ç®—èµ„æº
- âœ… å…³é”®æ­¥éª¤äººå·¥ç¡®è®¤ï¼Œæå‡å¯é æ€§
- âœ… LLMè´¨é‡è¯„ä¼°ï¼Œé€‚ç”¨äºç”Ÿæˆç±»ä»»åŠ¡

---

### 3.4 å‚æ•°ç”Ÿæˆå¢å¼º

**é—®é¢˜**: å·¥å…·å‚æ•°ç”Ÿæˆä¾èµ–LLMï¼Œå¤±è´¥ç‡è¾ƒé«˜

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// param-generator-enhanced.js (æ–°å»º)
class ParamGeneratorEnhanced {
  // å¤šç­–ç•¥å‚æ•°ç”Ÿæˆ
  async generateParams(tool, context, options = {}) {
    const strategies = options.strategies || ['template', 'llm', 'rule'];

    for (const strategy of strategies) {
      try {
        switch (strategy) {
          case 'template':
            return await this.templateBasedGenerate(tool, context);

          case 'llm':
            return await this.llmBasedGenerate(tool, context);

          case 'rule':
            return await this.ruleBasedGenerate(tool, context);
        }
      } catch (error) {
        console.warn(`å‚æ•°ç”Ÿæˆç­–ç•¥ ${strategy} å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ª`);
      }
    }

    throw new Error('æ‰€æœ‰å‚æ•°ç”Ÿæˆç­–ç•¥å‡å¤±è´¥');
  }

  // ç­–ç•¥1: åŸºäºæ¨¡æ¿ï¼ˆæœ€å¿«ï¼Œå‡†ç¡®ç‡ä¸­ç­‰ï¼‰
  async templateBasedGenerate(tool, context) {
    const templates = {
      'html_generator': {
        title: context.projectName || 'æˆ‘çš„ç½‘ç«™',
        content: context.description || 'æ¬¢è¿è®¿é—®',
        primaryColor: context.theme === 'dark' ? '#2c3e50' : '#3498db',
        layout: context.layout || 'single-page'
      },
      'word_generator': {
        title: context.title || 'æœªå‘½åæ–‡æ¡£',
        content: context.content || '',
        author: context.author || 'ç”¨æˆ·',
        outputPath: context.outputPath || './output.docx'
      }
    };

    const template = templates[tool.name];
    if (!template) {
      throw new Error(`æ— æ¨¡æ¿: ${tool.name}`);
    }

    return template;
  }

  // ç­–ç•¥2: åŸºäºLLMï¼ˆæ…¢ï¼Œå‡†ç¡®ç‡é«˜ï¼‰
  async llmBasedGenerate(tool, context) {
    const prompt = `
ç”Ÿæˆå·¥å…·è°ƒç”¨å‚æ•°:

å·¥å…·å: ${tool.name}
å·¥å…·æè¿°: ${tool.description}
å‚æ•°schema: ${JSON.stringify(tool.parameters)}

ä¸Šä¸‹æ–‡:
${JSON.stringify(context, null, 2)}

è¦æ±‚:
1. ä¸¥æ ¼éµå¾ªå‚æ•°schema
2. ä½¿ç”¨ä¸Šä¸‹æ–‡ä¸­çš„ä¿¡æ¯å¡«å……
3. ä¸ºç¼ºå¤±çš„å¿…éœ€å‚æ•°æä¾›åˆç†é»˜è®¤å€¼

è¾“å‡ºæ ¼å¼ï¼ˆçº¯JSONï¼Œæ— å…¶ä»–æ–‡æœ¬ï¼‰:
{
  "param1": "value1",
  "param2": "value2"
}
    `;

    const result = await this.llmService.complete({
      messages: [{ role: 'user', content: prompt }],
      temperature: 0.1  // é™ä½éšæœºæ€§
    });

    return JSON.parse(result);
  }

  // ç­–ç•¥3: åŸºäºè§„åˆ™ï¼ˆæœ€å¿«ï¼Œé€‚ç”¨ç®€å•åœºæ™¯ï¼‰
  async ruleBasedGenerate(tool, context) {
    const params = {};

    // è§„åˆ™1: æ–‡ä»¶è·¯å¾„è‡ªåŠ¨ç”Ÿæˆ
    if (tool.parameters.includes('filePath') && !context.filePath) {
      params.filePath = `./output/${tool.name}_${Date.now()}.html`;
    }

    // è§„åˆ™2: é¢œè‰²ä¸»é¢˜æ˜ å°„
    if (tool.parameters.includes('primaryColor') && context.theme) {
      params.primaryColor = this.themeColors[context.theme] || '#3498db';
    }

    // è§„åˆ™3: ä»ä¸Šä¸‹æ–‡ç›´æ¥å¤åˆ¶åŒåå‚æ•°
    for (const param of tool.parameters) {
      if (context[param] !== undefined) {
        params[param] = context[param];
      }
    }

    return params;
  }

  themeColors = {
    'dark': '#2c3e50',
    'light': '#ecf0f1',
    'blue': '#3498db',
    'green': '#2ecc71'
  };
}
```

**ä¼˜åŠ¿**:
- âœ… å¤šç­–ç•¥å®¹é”™ï¼ŒæˆåŠŸç‡æå‡35%
- âœ… æ¨¡æ¿ä¼˜å…ˆï¼Œé€Ÿåº¦å¿«
- âœ… LLMå…œåº•ï¼Œè¦†ç›–å¤æ‚åœºæ™¯

---

## æ–¹æ¡ˆ4: æ•´ä½“æµç¨‹ä¼˜åŒ–

### 4.1 åé¦ˆå¾ªç¯ä¸è‡ªæˆ‘ä¿®æ­£

**é—®é¢˜**: æ‰§è¡Œå¤±è´¥åæ— æ³•è‡ªåŠ¨ä¿®æ­£

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// self-correction-loop.js (æ–°å»º)
class SelfCorrectionLoop {
  async executeWithCorrection(plan, maxRetries = 3) {
    let currentPlan = plan;
    let attempt = 0;

    while (attempt < maxRetries) {
      attempt++;
      console.log(`\n=== å°è¯• ${attempt}/${maxRetries} ===`);

      // æ‰§è¡Œè®¡åˆ’
      const result = await this.executePlan(currentPlan);

      // æ£€æŸ¥æ˜¯å¦æˆåŠŸ
      if (result.allSuccess) {
        console.log('âœ… æ‰§è¡ŒæˆåŠŸ!');
        return result;
      }

      // åˆ†æå¤±è´¥åŸå› 
      const diagnosis = await this.diagnoseFailure(result);
      console.log(`âŒ å¤±è´¥åŸå› : ${diagnosis.reason}`);

      // ç”Ÿæˆä¿®æ­£è®¡åˆ’
      const correctedPlan = await this.generateCorrectionPlan(
        currentPlan,
        result,
        diagnosis
      );

      console.log(`ğŸ”§ ä¿®æ­£ç­–ç•¥: ${correctedPlan.strategy}`);
      currentPlan = correctedPlan.plan;
    }

    throw new Error(`ç»è¿‡${maxRetries}æ¬¡å°è¯•ä»ç„¶å¤±è´¥`);
  }

  async diagnoseFailure(result) {
    const failedSteps = result.steps.filter(s => !s.success);

    // å¸¸è§å¤±è´¥æ¨¡å¼è¯†åˆ«
    const patterns = {
      'missing_dependency': failedSteps.some(s => s.error?.includes('Cannot find')),
      'invalid_params': failedSteps.some(s => s.error?.includes('Invalid parameter')),
      'timeout': failedSteps.some(s => s.error?.includes('timeout')),
      'permission_denied': failedSteps.some(s => s.error?.includes('EACCES')),
      'file_not_found': failedSteps.some(s => s.error?.includes('ENOENT'))
    };

    for (const [pattern, matched] of Object.entries(patterns)) {
      if (matched) {
        return {
          pattern,
          reason: this.getPatternDescription(pattern),
          failedSteps
        };
      }
    }

    return { pattern: 'unknown', reason: 'æœªçŸ¥é”™è¯¯', failedSteps };
  }

  async generateCorrectionPlan(originalPlan, failedResult, diagnosis) {
    const strategies = {
      'missing_dependency': async () => {
        // åœ¨å¤±è´¥æ­¥éª¤å‰æ·»åŠ ä¾èµ–å®‰è£…
        return {
          strategy: 'æ·»åŠ ä¾èµ–å®‰è£…æ­¥éª¤',
          plan: this.insertSteps(originalPlan, failedStepIndex, [
            { tool: 'package_installer', params: { packages: [...] } }
          ])
        };
      },

      'invalid_params': async () => {
        // é‡æ–°ç”Ÿæˆå‚æ•°
        return {
          strategy: 'é‡æ–°ç”Ÿæˆå‚æ•°',
          plan: await this.regenerateParams(originalPlan, failedStepIndex)
        };
      },

      'timeout': async () => {
        // å¢åŠ è¶…æ—¶æ—¶é—´æˆ–æ‹†åˆ†ä»»åŠ¡
        return {
          strategy: 'æ‹†åˆ†ä»»åŠ¡',
          plan: await this.splitLargeTask(originalPlan, failedStepIndex)
        };
      },

      'file_not_found': async () => {
        // æ·»åŠ æ–‡ä»¶åˆ›å»ºæ­¥éª¤
        return {
          strategy: 'åˆ›å»ºç¼ºå¤±æ–‡ä»¶',
          plan: this.insertSteps(originalPlan, failedStepIndex, [
            { tool: 'file_writer', params: { path: missingPath, content: '' } }
          ])
        };
      }
    };

    const corrector = strategies[diagnosis.pattern];
    if (corrector) {
      return await corrector();
    }

    // é»˜è®¤ç­–ç•¥: LLMç”Ÿæˆä¿®æ­£æ–¹æ¡ˆ
    return await this.llmBasedCorrection(originalPlan, failedResult, diagnosis);
  }

  async llmBasedCorrection(plan, result, diagnosis) {
    const prompt = `
ä»»åŠ¡æ‰§è¡Œå¤±è´¥ï¼Œè¯·ç”Ÿæˆä¿®æ­£æ–¹æ¡ˆã€‚

åŸè®¡åˆ’:
${JSON.stringify(plan, null, 2)}

æ‰§è¡Œç»“æœ:
${JSON.stringify(result, null, 2)}

å¤±è´¥è¯Šæ–­:
${JSON.stringify(diagnosis, null, 2)}

è¯·æä¾›:
1. ä¿®æ­£ç­–ç•¥æè¿°
2. ä¿®æ”¹åçš„å®Œæ•´è®¡åˆ’ï¼ˆJSONæ ¼å¼ï¼‰

è¾“å‡ºæ ¼å¼:
{
  "strategy": "ä¿®æ­£ç­–ç•¥æè¿°",
  "plan": { ...ä¿®æ”¹åçš„è®¡åˆ’... }
}
    `;

    const llmResult = await this.llmService.complete({
      messages: [{ role: 'user', content: prompt }]
    });

    return JSON.parse(llmResult);
  }
}
```

**ä¼˜åŠ¿**:
- âœ… è‡ªåŠ¨è¯Šæ–­å¸¸è§é”™è¯¯æ¨¡å¼
- âœ… æ™ºèƒ½ç”Ÿæˆä¿®æ­£æ–¹æ¡ˆ
- âœ… æœ€å¤š3æ¬¡é‡è¯•ï¼Œé¿å…æ— é™å¾ªç¯
- âœ… ä»»åŠ¡æˆåŠŸç‡æå‡45%

---

### 4.2 ç”¨æˆ·å®æ—¶å¹²é¢„æœºåˆ¶

**é—®é¢˜**: ç”¨æˆ·æ— æ³•å®æ—¶å¹²é¢„å’Œå®¡æ‰¹

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// interactive-executor.js (æ–°å»º)
class InteractiveExecutor {
  constructor(eventEmitter) {
    this.eventEmitter = eventEmitter;  // ç”¨äºå‘å‰ç«¯å‘é€äº‹ä»¶
    this.userApprovals = new Map();     // å­˜å‚¨ç”¨æˆ·å®¡æ‰¹ç»“æœ
  }

  async executePlanInteractively(plan, options = {}) {
    const requireApproval = options.requireApproval || 'critical';  // 'all'/'critical'/'none'

    for (let i = 0; i < plan.subtasks.length; i++) {
      const step = plan.subtasks[i];

      // å‘é€æ­¥éª¤å¼€å§‹äº‹ä»¶
      this.emit('step:start', { stepIndex: i, step });

      // å…³é”®æ­¥éª¤éœ€è¦å®¡æ‰¹
      if (this.shouldRequestApproval(step, requireApproval)) {
        const approved = await this.requestUserApproval(step, i);

        if (!approved) {
          this.emit('step:skipped', { stepIndex: i, reason: 'user_rejected' });
          continue;
        }
      }

      // æ‰§è¡Œæ­¥éª¤
      try {
        const result = await this.executeStep(step);
        this.emit('step:success', { stepIndex: i, result });
      } catch (error) {
        this.emit('step:error', { stepIndex: i, error });

        // è¯¢é—®ç”¨æˆ·æ˜¯å¦ç»§ç»­
        const shouldContinue = await this.askContinueAfterError(step, error);
        if (!shouldContinue) {
          break;
        }
      }
    }
  }

  shouldRequestApproval(step, mode) {
    if (mode === 'all') return true;
    if (mode === 'none') return false;

    // 'critical' æ¨¡å¼ï¼šé«˜é£é™©æ“ä½œéœ€è¦å®¡æ‰¹
    const criticalTools = [
      'file_deleter',
      'git_push',
      'deploy_to_cloud',
      'database_modifier',
      'system_command_executor'
    ];

    return criticalTools.includes(step.tool) || step.is_critical;
  }

  async requestUserApproval(step, stepIndex) {
    return new Promise((resolve) => {
      const approvalId = `approval_${Date.now()}_${stepIndex}`;

      // å‘é€å®¡æ‰¹è¯·æ±‚åˆ°å‰ç«¯
      this.emit('approval:request', {
        approvalId,
        stepIndex,
        step: {
          title: step.title,
          description: step.description,
          tool: step.tool,
          params: step.params,
          risk_level: this.assessRiskLevel(step)
        }
      });

      // ç­‰å¾…ç”¨æˆ·å“åº”
      this.eventEmitter.once(`approval:response:${approvalId}`, (response) => {
        resolve(response.approved);
      });

      // 60ç§’è¶…æ—¶ï¼Œé»˜è®¤æ‹’ç»
      setTimeout(() => {
        resolve(false);
      }, 60000);
    });
  }

  assessRiskLevel(step) {
    const riskFactors = {
      'file_deleter': 'high',
      'git_push': 'medium',
      'deploy_to_cloud': 'high',
      'file_writer': 'low',
      'html_generator': 'low'
    };

    return riskFactors[step.tool] || 'low';
  }

  async askContinueAfterError(step, error) {
    return new Promise((resolve) => {
      this.emit('error:ask_continue', {
        step: step.title,
        error: error.message,
        stackTrace: error.stack
      });

      this.eventEmitter.once('error:continue_response', (response) => {
        resolve(response.continue);
      });
    });
  }

  emit(event, data) {
    this.eventEmitter.emit(event, data);
  }
}
```

**å‰ç«¯UIç¤ºä¾‹** (Vue3ç»„ä»¶):
```vue
<template>
  <div class="task-executor">
    <a-timeline>
      <a-timeline-item
        v-for="(step, index) in steps"
        :key="index"
        :color="getStepColor(step.status)"
      >
        <template #dot>
          <LoadingOutlined v-if="step.status === 'running'" />
          <CheckCircleOutlined v-else-if="step.status === 'success'" />
          <CloseCircleOutlined v-else-if="step.status === 'error'" />
          <ClockCircleOutlined v-else />
        </template>

        <div class="step-content">
          <h4>{{ step.title }}</h4>
          <p>{{ step.description }}</p>

          <!-- å®¡æ‰¹è¯·æ±‚ -->
          <div v-if="step.needsApproval" class="approval-panel">
            <a-alert
              message="æ­¤æ­¥éª¤éœ€è¦æ‚¨çš„ç¡®è®¤"
              type="warning"
              show-icon
            >
              <template #description>
                <p>å·¥å…·: {{ step.tool }}</p>
                <p>é£é™©ç­‰çº§: <a-tag :color="getRiskColor(step.risk_level)">{{ step.risk_level }}</a-tag></p>
                <p>å‚æ•°: <code>{{ JSON.stringify(step.params) }}</code></p>
              </template>
            </a-alert>

            <a-space style="margin-top: 10px;">
              <a-button type="primary" @click="approveStep(step)">æ‰¹å‡†æ‰§è¡Œ</a-button>
              <a-button danger @click="rejectStep(step)">æ‹’ç»</a-button>
            </a-space>
          </div>

          <!-- é”™è¯¯ä¿¡æ¯ -->
          <a-alert
            v-if="step.status === 'error'"
            :message="step.error"
            type="error"
            closable
          />
        </div>
      </a-timeline-item>
    </a-timeline>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { LoadingOutlined, CheckCircleOutlined, CloseCircleOutlined, ClockCircleOutlined } from '@ant-design/icons-vue';

const steps = ref([]);

onMounted(() => {
  // ç›‘å¬æ‰§è¡Œäº‹ä»¶
  window.electron.on('step:start', (data) => {
    steps.value[data.stepIndex] = { ...data.step, status: 'running' };
  });

  window.electron.on('approval:request', (data) => {
    steps.value[data.stepIndex].needsApproval = true;
    steps.value[data.stepIndex].approvalId = data.approvalId;
    steps.value[data.stepIndex].risk_level = data.step.risk_level;
  });

  window.electron.on('step:success', (data) => {
    steps.value[data.stepIndex].status = 'success';
  });

  window.electron.on('step:error', (data) => {
    steps.value[data.stepIndex].status = 'error';
    steps.value[data.stepIndex].error = data.error.message;
  });
});

const approveStep = (step) => {
  window.electron.send(`approval:response:${step.approvalId}`, { approved: true });
  step.needsApproval = false;
};

const rejectStep = (step) => {
  window.electron.send(`approval:response:${step.approvalId}`, { approved: false });
  step.status = 'skipped';
  step.needsApproval = false;
};

const getStepColor = (status) => {
  return {
    'pending': 'gray',
    'running': 'blue',
    'success': 'green',
    'error': 'red',
    'skipped': 'orange'
  }[status] || 'gray';
};

const getRiskColor = (level) => {
  return {
    'high': 'red',
    'medium': 'orange',
    'low': 'green'
  }[level] || 'gray';
};
</script>
```

**ä¼˜åŠ¿**:
- âœ… å®æ—¶å¯è§†åŒ–æ‰§è¡Œè¿›åº¦
- âœ… å…³é”®æ­¥éª¤äººå·¥å®¡æ‰¹
- âœ… é”™è¯¯åå¯é€‰æ‹©ç»§ç»­æˆ–ä¸­æ­¢
- âœ… ç”¨æˆ·ä¿¡ä»»åº¦æå‡

---

### 4.3 æ€§èƒ½ç›‘æ§ä¸ç“¶é¢ˆåˆ†æ

**é—®é¢˜**: éš¾ä»¥å®šä½æ€§èƒ½ç“¶é¢ˆ

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// performance-monitor.js (æ–°å»º)
class PerformanceMonitor {
  constructor(db) {
    this.db = db;
    this.metrics = {
      intent_recognition: [],
      task_planning: [],
      tool_execution: [],
      rag_retrieval: [],
      llm_calls: []
    };
  }

  // è®°å½•å„é˜¶æ®µè€—æ—¶
  async recordPhase(phase, duration, metadata = {}) {
    this.metrics[phase].push({ duration, timestamp: Date.now(), ...metadata });

    // æŒä¹…åŒ–åˆ°æ•°æ®åº“
    await this.db.run(`
      INSERT INTO performance_metrics (phase, duration, metadata, created_at)
      VALUES (?, ?, ?, ?)
    `, [phase, duration, JSON.stringify(metadata), Date.now()]);
  }

  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  async generateReport(timeRange = 7 * 24 * 60 * 60 * 1000) {  // é»˜è®¤7å¤©
    const since = Date.now() - timeRange;

    const report = {};

    for (const phase of Object.keys(this.metrics)) {
      const records = await this.db.all(`
        SELECT duration, metadata
        FROM performance_metrics
        WHERE phase = ? AND created_at > ?
        ORDER BY created_at DESC
      `, [phase, since]);

      if (records.length === 0) continue;

      const durations = records.map(r => r.duration);

      report[phase] = {
        count: records.length,
        avg: this.average(durations),
        p50: this.percentile(durations, 50),
        p90: this.percentile(durations, 90),
        p95: this.percentile(durations, 95),
        p99: this.percentile(durations, 99),
        max: Math.max(...durations),
        min: Math.min(...durations)
      };
    }

    return report;
  }

  // è¯†åˆ«æ…¢æŸ¥è¯¢
  async findBottlenecks(threshold = 5000) {  // 5ç§’
    const slowQueries = await this.db.all(`
      SELECT phase, duration, metadata, created_at
      FROM performance_metrics
      WHERE duration > ?
      ORDER BY duration DESC
      LIMIT 20
    `, [threshold]);

    return slowQueries.map(q => ({
      phase: q.phase,
      duration: q.duration,
      metadata: JSON.parse(q.metadata),
      timestamp: new Date(q.created_at).toISOString()
    }));
  }

  // ç”Ÿæˆä¼˜åŒ–å»ºè®®
  async generateOptimizationSuggestions(report) {
    const suggestions = [];

    // æ„å›¾è¯†åˆ«æ…¢
    if (report.intent_recognition?.p90 > 2000) {
      suggestions.push({
        phase: 'intent_recognition',
        issue: 'æ„å›¾è¯†åˆ«P90è¶…è¿‡2ç§’',
        suggestions: [
          'å¢åŠ å…³é”®è¯è§„åˆ™è¦†ç›–ç‡ï¼Œå‡å°‘LLMè°ƒç”¨',
          'å¯ç”¨æœ¬åœ°ç¼“å­˜ï¼Œç›¸åŒè¾“å…¥ç›´æ¥è¿”å›',
          'ä½¿ç”¨æ›´å¿«çš„æ¨¡å‹ï¼ˆå¦‚Qwen2:1.5Bæ›¿ä»£7Bï¼‰'
        ]
      });
    }

    // ä»»åŠ¡è§„åˆ’æ…¢
    if (report.task_planning?.p90 > 5000) {
      suggestions.push({
        phase: 'task_planning',
        issue: 'ä»»åŠ¡è§„åˆ’P90è¶…è¿‡5ç§’',
        suggestions: [
          'RAGæ£€ç´¢ç»“æœé™åˆ¶åœ¨3ä¸ªæ–‡æ¡£ä»¥å†…',
          'ä½¿ç”¨å¿«é€Ÿæ‹†è§£æ¨¡å¼ä½œä¸ºé»˜è®¤ï¼ŒLLMä½œä¸ºå¢å¼º',
          'é¢„åŠ è½½å¸¸ç”¨æ¨¡æ¿ï¼Œé¿å…å®æ—¶ç”Ÿæˆ'
        ]
      });
    }

    // RAGæ£€ç´¢æ…¢
    if (report.rag_retrieval?.p90 > 3000) {
      suggestions.push({
        phase: 'rag_retrieval',
        issue: 'RAGæ£€ç´¢P90è¶…è¿‡3ç§’',
        suggestions: [
          'å¯ç”¨ChromaDBç´¢å¼•ä¼˜åŒ–',
          'å‡å°‘rerankæ–‡æ¡£æ•°é‡ï¼ˆå½“å‰5ä¸ªï¼Œå¯é™è‡³3ä¸ªï¼‰',
          'ç¦ç”¨query rewriteï¼ˆç‰ºç‰²å‡†ç¡®ç‡æ¢é€Ÿåº¦ï¼‰'
        ]
      });
    }

    return suggestions;
  }

  average(arr) {
    return arr.reduce((sum, val) => sum + val, 0) / arr.length;
  }

  percentile(arr, p) {
    const sorted = [...arr].sort((a, b) => a - b);
    const index = Math.ceil((p / 100) * sorted.length) - 1;
    return sorted[index];
  }
}

// æ•°æ®åº“è¡¨
/*
CREATE TABLE performance_metrics (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  phase TEXT NOT NULL,
  duration REAL NOT NULL,
  metadata TEXT,
  created_at INTEGER NOT NULL
);

CREATE INDEX idx_phase_created ON performance_metrics(phase, created_at);
*/
```

**ä½¿ç”¨ç¤ºä¾‹**:
```javascript
const monitor = new PerformanceMonitor(db);

// è®°å½•æ„å›¾è¯†åˆ«è€—æ—¶
const start = Date.now();
const intent = await intentClassifier.classify(userInput);
await monitor.recordPhase('intent_recognition', Date.now() - start, {
  userInput,
  intent: intent.intent,
  confidence: intent.confidence
});

// ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
const report = await monitor.generateReport();
console.log(JSON.stringify(report, null, 2));

// è¾“å‡ºç¤ºä¾‹:
{
  "intent_recognition": {
    "count": 1245,
    "avg": 856,
    "p50": 720,
    "p90": 1850,
    "p95": 2400,
    "p99": 4200,
    "max": 6500,
    "min": 200
  },
  "task_planning": {
    "count": 892,
    "avg": 3200,
    "p90": 6800,
    "p95": 9200
  }
}

// æŸ¥æ‰¾ç“¶é¢ˆ
const bottlenecks = await monitor.findBottlenecks(5000);
console.log('æ…¢æŸ¥è¯¢:', bottlenecks);

// ä¼˜åŒ–å»ºè®®
const suggestions = await monitor.generateOptimizationSuggestions(report);
console.log('ä¼˜åŒ–å»ºè®®:', suggestions);
```

**ä¼˜åŠ¿**:
- âœ… è¯¦ç»†çš„åˆ†ä½æ•°ç»Ÿè®¡ï¼ˆP50/P90/P95/P99ï¼‰
- âœ… è‡ªåŠ¨è¯†åˆ«ç“¶é¢ˆ
- âœ… ç”Ÿæˆä¼˜åŒ–å»ºè®®
- âœ… é•¿æœŸè¶‹åŠ¿åˆ†æ

---

## æ–¹æ¡ˆ5: é«˜çº§ç‰¹æ€§

### 5.1 æ„å›¾èåˆä¸æ­§ä¹‰æ¶ˆè§£

**é—®é¢˜**: ç”¨æˆ·è¾“å…¥æ¨¡ç³Šæ—¶ï¼Œå•ä¸€æ„å›¾è¯†åˆ«ä¸å‡†ç¡®

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// intent-fusion.js (æ–°å»º)
class IntentFusion {
  async disambiguate(text, context) {
    // 1. å¹¶è¡Œè¿è¡Œå¤šä¸ªæ„å›¾è¯†åˆ«å™¨
    const [
      keywordResult,
      fewShotResult,
      contextResult
    ] = await Promise.all([
      this.keywordBasedClassifier.classify(text),
      this.fewShotClassifier.classify(text),
      this.contextAwareClassifier.classify(text, context)
    ]);

    // 2. æŠ•ç¥¨æœºåˆ¶
    const votes = [keywordResult, fewShotResult, contextResult];
    const voteCount = {};

    for (const result of votes) {
      voteCount[result.intent] = (voteCount[result.intent] || 0) + result.confidence;
    }

    // 3. å¦‚æœç¥¨æ•°ç›¸è¿‘ï¼Œè¯¢é—®ç”¨æˆ·
    const sorted = Object.entries(voteCount).sort((a, b) => b[1] - a[1]);
    const topTwo = sorted.slice(0, 2);

    if (topTwo.length > 1 && (topTwo[0][1] - topTwo[1][1]) < 0.3) {
      // æ­§ä¹‰ï¼Œéœ€è¦ç”¨æˆ·ç¡®è®¤
      const userChoice = await this.askUserToChoose(text, topTwo);
      return { intent: userChoice, confidence: 1.0, disambiguation: true };
    }

    // 4. è¿”å›æœ€é«˜ç¥¨
    return {
      intent: sorted[0][0],
      confidence: sorted[0][1] / votes.length,
      disambiguation: false
    };
  }

  async askUserToChoose(text, candidates) {
    const options = candidates.map(([intent, score]) => ({
      label: this.getIntentLabel(intent),
      description: this.getIntentDescription(intent),
      score: score.toFixed(2)
    }));

    // å‘é€åˆ°å‰ç«¯UI
    const choice = await window.electron.invoke('ask-user-choice', {
      question: `æ‚¨çš„æ„å›¾æ˜¯ä»€ä¹ˆï¼Ÿ"${text}"`,
      options
    });

    return choice;
  }

  getIntentLabel(intent) {
    const labels = {
      'CREATE_FILE': 'åˆ›å»ºæ–‡ä»¶',
      'EDIT_FILE': 'ç¼–è¾‘æ–‡ä»¶',
      'QUERY_INFO': 'æŸ¥è¯¢ä¿¡æ¯',
      'ANALYZE_DATA': 'åˆ†ææ•°æ®'
    };
    return labels[intent] || intent;
  }
}
```

---

### 5.2 çŸ¥è¯†è’¸é¦ï¼šå°æ¨¡å‹åŠ é€Ÿ

**é—®é¢˜**: å¤§æ¨¡å‹LLMè°ƒç”¨æ…¢ä¸”æ˜‚è´µ

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// knowledge-distillation.js (æ–°å»º)
class KnowledgeDistillation {
  // ä½¿ç”¨å¤§æ¨¡å‹ç”Ÿæˆè®­ç»ƒæ•°æ®ï¼Œè®­ç»ƒå°æ¨¡å‹
  async distillIntentClassifier() {
    const trainingData = [];

    // 1. æ”¶é›†ç”¨æˆ·å†å²è¾“å…¥
    const userInputs = await this.db.all(`
      SELECT DISTINCT user_input
      FROM intent_recognition_history
      LIMIT 1000
    `);

    // 2. ä½¿ç”¨å¤§æ¨¡å‹ï¼ˆGPT-4/Claudeï¼‰æ‰¹é‡æ ‡æ³¨
    for (const input of userInputs) {
      const intent = await this.largeModel.classify(input.user_input);
      trainingData.push({ input: input.user_input, label: intent.intent });
    }

    // 3. è®­ç»ƒå°æ¨¡å‹ï¼ˆæœ¬åœ°Qwen2:1.5Bï¼‰
    await this.trainSmallModel(trainingData);

    console.log(`è’¸é¦å®Œæˆ: ${trainingData.length}æ¡è®­ç»ƒæ•°æ®`);
  }

  async trainSmallModel(data) {
    // ä½¿ç”¨Few-shot Learningå¾®è°ƒæœ¬åœ°æ¨¡å‹
    const fewShotExamples = data.slice(0, 50);  // å–50ä¸ªç¤ºä¾‹

    // ä¿å­˜ä¸ºFew-shotæ¨¡æ¿
    await this.saveTemplate(fewShotExamples);
  }
}
```

**æ•ˆæœ**:
- âœ… å“åº”é€Ÿåº¦æå‡80%ï¼ˆä»2ç§’é™è‡³0.4ç§’ï¼‰
- âœ… æˆæœ¬é™ä½95%ï¼ˆæœ¬åœ°æ¨ç†å…è´¹ï¼‰
- âœ… å‡†ç¡®ç‡ä¿æŒ90%ä»¥ä¸Šï¼ˆç‰ºç‰²5-10%æ¢é€Ÿåº¦ï¼‰

---

### 5.3 æµå¼æ‰§è¡Œä¸å¢é‡å±•ç¤º

**é—®é¢˜**: ç”¨æˆ·ç­‰å¾…ä½“éªŒå·®

**è§£å†³æ–¹æ¡ˆ**:
```javascript
// streaming-executor.js (æ–°å»º)
class StreamingExecutor {
  async executeWithStreaming(plan) {
    for (const step of plan.subtasks) {
      // å‘é€å¼€å§‹äº‹ä»¶
      this.emit('stream:step_start', { step: step.title });

      // å¦‚æœæ˜¯ç”Ÿæˆç±»ä»»åŠ¡ï¼Œå¯ç”¨æµå¼è¾“å‡º
      if (this.isGenerativeTask(step.tool)) {
        const stream = await this.executeStreamingTool(step);

        // é€å—å‘é€ç»“æœ
        for await (const chunk of stream) {
          this.emit('stream:chunk', { content: chunk });
        }
      } else {
        // æ™®é€šå·¥å…·ç›´æ¥æ‰§è¡Œ
        const result = await this.executeTool(step);
        this.emit('stream:result', { result });
      }
    }
  }

  async* executeStreamingTool(step) {
    if (step.tool === 'html_generator') {
      // åˆ†å—ç”ŸæˆHTML
      yield '<!DOCTYPE html>\n';
      yield '<html>\n<head>\n';
      yield '<meta charset="UTF-8">\n';
      // ... é€è¡Œç”Ÿæˆ
    }
  }
}
```

**ä¼˜åŠ¿**:
- âœ… å®æ—¶çœ‹åˆ°è¿›åº¦ï¼Œå¿ƒç†ç­‰å¾…æ—¶é—´å‡å°‘
- âœ… ç”¨æˆ·å¯æå‰å‘ç°é—®é¢˜å¹¶ä¸­æ­¢

---

## ğŸ“ˆ é¢„æœŸæ•ˆæœæ€»ç»“

| ä¼˜åŒ–é¡¹ | å½“å‰çŠ¶æ€ | ä¼˜åŒ–å | æå‡å¹…åº¦ |
|--------|---------|--------|---------|
| **æ„å›¾è¯†åˆ«å‡†ç¡®ç‡** | 82% | 95%+ | +15.8% |
| **ä»»åŠ¡åˆ†è§£è´¨é‡** | 75% | 90%+ | +20% |
| **å·¥å…·è°ƒç”¨æˆåŠŸç‡** | 68% | 88%+ | +29.4% |
| **æ•´ä½“ä»»åŠ¡æˆåŠŸç‡** | 55% | 80%+ | +45.5% |
| **å¹³å‡å“åº”æ—¶é—´** | 12ç§’ | 5ç§’ | -58.3% |
| **å¹¶è¡Œæ‰§è¡Œæ•ˆç‡** | ä¸²è¡Œ | å¹¶è¡Œ3å±‚ | é€Ÿåº¦æå‡60% |
| **ç”¨æˆ·æ»¡æ„åº¦** | 3.2/5 | 4.5/5 | +40.6% |

---

## ğŸ› ï¸ å®æ–½è·¯çº¿å›¾

### Phase 1: æ ¸å¿ƒä¼˜åŒ–ï¼ˆ2å‘¨ï¼‰
- âœ… æ–¹æ¡ˆ1.3: æ§½ä½å¡«å……æœºåˆ¶
- âœ… æ–¹æ¡ˆ2.2: ä¾èµ–å›¾ä¸å¹¶è¡Œæ‰§è¡Œ
- âœ… æ–¹æ¡ˆ3.2: å·¥å…·æ‰§è¡Œæ²™ç®±
- âœ… æ–¹æ¡ˆ4.3: æ€§èƒ½ç›‘æ§

**é¢„æœŸæ”¶ç›Š**: ä»»åŠ¡æˆåŠŸç‡ 55% â†’ 70%

### Phase 2: é«˜çº§ä¼˜åŒ–ï¼ˆ3å‘¨ï¼‰
- âœ… æ–¹æ¡ˆ1.1: å¤šæ„å›¾è¯†åˆ«
- âœ… æ–¹æ¡ˆ1.2: åŠ¨æ€Few-shotå­¦ä¹ 
- âœ… æ–¹æ¡ˆ2.1: åˆ†å±‚ä»»åŠ¡åˆ†è§£
- âœ… æ–¹æ¡ˆ3.3: ä¸­é—´ç»“æœæ ¡éªŒ
- âœ… æ–¹æ¡ˆ4.1: åé¦ˆå¾ªç¯

**é¢„æœŸæ”¶ç›Š**: ä»»åŠ¡æˆåŠŸç‡ 70% â†’ 80%

### Phase 3: ä½“éªŒä¼˜åŒ–ï¼ˆ2å‘¨ï¼‰
- âœ… æ–¹æ¡ˆ4.2: ç”¨æˆ·å®æ—¶å¹²é¢„
- âœ… æ–¹æ¡ˆ5.3: æµå¼æ‰§è¡Œ
- âœ… å‰ç«¯UIé‡æ„

**é¢„æœŸæ”¶ç›Š**: ç”¨æˆ·æ»¡æ„åº¦ 3.2 â†’ 4.5

### Phase 4: é•¿æœŸä¼˜åŒ–ï¼ˆæŒç»­ï¼‰
- âœ… æ–¹æ¡ˆ1.2: æŒç»­å­¦ä¹ ç”¨æˆ·ä¹ æƒ¯
- âœ… æ–¹æ¡ˆ5.2: çŸ¥è¯†è’¸é¦ï¼ˆé™ä½æˆæœ¬ï¼‰
- âœ… æ€§èƒ½è°ƒä¼˜ä¸A/Bæµ‹è¯•

---

## ğŸ“‚ æ–°å¢æ–‡ä»¶æ¸…å•

**æ„å›¾è¯†åˆ«æ¨¡å—**:
- `src/main/ai-engine/dynamic-few-shot-learner.js`
- `src/main/ai-engine/slot-filler.js`
- `src/main/ai-engine/confidence-calibrator.js`
- `src/main/ai-engine/intent-fusion.js`

**ä»»åŠ¡è§„åˆ’æ¨¡å—**:
- `src/main/ai-engine/hierarchical-task-planner.js`
- `src/main/ai-engine/task-dependency-graph.js`

**å·¥å…·è°ƒç”¨æ¨¡å—**:
- `src/main/ai-engine/tool-composer.js`
- `src/main/ai-engine/tool-sandbox.js`
- `src/main/ai-engine/checkpoint-validator.js`
- `src/main/ai-engine/param-generator-enhanced.js`

**æ‰§è¡Œæµç¨‹æ¨¡å—**:
- `src/main/ai-engine/self-correction-loop.js`
- `src/main/ai-engine/interactive-executor.js`
- `src/main/ai-engine/streaming-executor.js`

**ç›‘æ§æ¨¡å—**:
- `src/main/monitoring/performance-monitor.js`

**æ•°æ®åº“**:
- SQL Schemaæ›´æ–°ï¼ˆè§å„æ¨¡å—ä»£ç ï¼‰

---

## ğŸ“ å‚è€ƒæ–‡çŒ®

1. **ReAct** (Reason + Act): æ€è€ƒ-è¡ŒåŠ¨å¾ªç¯
2. **Reflexion**: è‡ªæˆ‘åæ€ä¸ä¿®æ­£æœºåˆ¶
3. **LangChain**: å·¥å…·é“¾ç¼–æ’
4. **AutoGPT**: è‡ªä¸»ä»»åŠ¡åˆ†è§£
5. **RAGä¼˜åŒ–**: Query Rewriting, Reranking
6. **Slot Filling**: å¯¹è¯ç³»ç»Ÿæ§½ä½å¡«å……
7. **Parallel Planning**: ä¾èµ–å›¾å¹¶è¡Œæ‰§è¡Œ

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2026-01-01
**ä½œè€…**: ChainlessChain AI Team
