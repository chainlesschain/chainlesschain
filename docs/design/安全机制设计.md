# 安全机制设计

> 本文档是 [系统设计主文档](系统设计_主文档.md) 的子文档，详细描述U盾和SIMKey安全机制的设计。

---

## 3.1 U盾安全机制

### 3.1.1 U盾架构

```
U盾 (USB Key)
├── 硬件层
│   ├── 安全芯片 (SE - Secure Element)
│   ├── USB接口控制器
│   ├── 闪存存储 (存储公钥、证书、配置)
│   └── 随机数生成器 (TRNG)
│
├── 固件层
│   ├── PIN验证模块 (防暴力破解)
│   ├── 密钥生成模块
│   ├── 加密/解密引擎 (RSA-2048/4096, AES-256)
│   ├── 签名验证模块 (RSA/ECDSA)
│   └── 生命周期管理 (初始化、锁定、解锁、重置)
│
└── API层
    ├── PKCS#11接口 (通用加密API)
    ├── 自定义SDK (针对本系统)
    └── 驱动程序 (Windows/Linux/Mac)
```

### 3.1.2 密钥管理

**密钥层次结构**:

```
主密钥 (Master Key) - 永不导出,仅存U盾内
├── 设备签名密钥 (Device Sign Key)
│   └── 用途: 签名DID文档、交易、消息
│
├── 设备加密密钥 (Device Encrypt Key)
│   └── 用途: 接收加密消息、文件
│
├── 数据库加密密钥 (DB Encryption Key)
│   └── 用途: 加密SQLCipher数据库
│
└── 备份加密密钥 (Backup Encryption Key)
    └── 用途: 加密Git仓库、云备份
```

**密钥生成流程**:

```
1. 用户插入U盾
2. 输入PIN码解锁
3. 调用U盾API生成密钥对
   - RSA-4096 (兼容性好,适合签名)
   - 或 Ed25519 (高效,256位安全性)
4. 私钥写入安全芯片 (标记为不可导出)
5. 公钥导出并存储到应用数据库
6. 生成对应的DID标识符
```

**安全操作**:

```c
// U盾签名操作示例
int ukey_sign_data(const char* data, size_t data_len,
                   unsigned char* signature, size_t* sig_len) {
    // 1. 验证U盾连接
    if (!ukey_is_connected()) return ERROR_UKEY_NOT_FOUND;

    // 2. 验证PIN (带重试次数限制)
    if (!ukey_verify_pin(pin, &retries_left)) {
        if (retries_left == 0) {
            ukey_lock();  // PIN错误次数过多,锁定U盾
        }
        return ERROR_INVALID_PIN;
    }

    // 3. 计算数据哈希
    unsigned char hash[32];
    sha256(data, data_len, hash);

    // 4. 调用安全芯片签名 (私钥永不离开芯片)
    int ret = se_sign(DEVICE_SIGN_KEY_ID, hash, 32, signature, sig_len);

    return ret;
}
```

### 3.1.3 备份与恢复

**备份方案**:

```
方案一: 助记词备份 (BIP39)
1. 生成256位熵
2. 转换为24个助记词
3. 用户抄写并安全保存 (纸质、金属板)
4. 可选加密助记词 (需要额外密码)
5. 从助记词可恢复所有密钥

方案二: 备份U盾
1. 制作2-3个备份U盾
2. 将私钥安全导出并写入备份U盾
   (需要管理员级别权限和二次验证)
3. 备份U盾存放在不同物理位置

方案三: 社交恢复 (Shamir秘密共享)
1. 将主密钥分割为N份 (如5份)
2. 任意M份可恢复 (如3份)
3. 分发给可信朋友/家人
4. 丢失U盾时向他们请求恢复
```

**U盾丢失恢复流程**:

```
1. 用户使用助记词或备份U盾
2. 生成新的U盾并导入密钥
3. 登录系统后发布DID更新事件
   - 声明旧U盾已作废
   - 发布新的设备公钥
   - 使用旧私钥签名证明身份连续性
4. 通知所有联系人更新公钥
5. 旧U盾私钥加入黑名单
```

## 3.2 SIMKey安全机制

### 3.2.1 SIMKey架构

```
SIMKey (SIM卡安全芯片)
├── 硬件层
│   ├── SIM卡芯片 (Java Card或类似)
│   ├── 安全存储区域 (几十KB)
│   └── 加密协处理器
│
├── Applet层 (在SIM卡上运行的小程序)
│   ├── PIN管理
│   ├── 密钥生成 (RSA/ECC)
│   ├── 签名/验证
│   ├── 加密/解密
│   └── 安全存储API
│
└── 移动端接口
    ├── Android: OMAPI (Open Mobile API)
    ├── iOS: 需要运营商支持的特殊API
    └── APDU命令 (Application Protocol Data Unit)
```

### 3.2.2 SIMKey优势

- **始终在线**: 手机随身携带,SIM卡始终在手机中
- **运营商背书**: 实名制SIM卡提供额外身份保证
- **难以复制**: SIM卡丢失后可挂失,防止冒用
- **普及性高**: 无需额外硬件,人人都有SIM卡

### 3.2.3 SIMKey操作示例

**Android OMAPI通信**:

```java
// 打开SIM卡安全通道
SEService seService = new SEService(context, new SEService.OnConnectedListener() {
    @Override
    public void onConnected() {
        Reader[] readers = seService.getReaders();
        for (Reader reader : readers) {
            if (reader.getName().contains("SIM")) {
                Session session = reader.openSession();
                // 选择我们的Applet
                Channel channel = session.openLogicalChannel(APPLET_AID);

                // 发送签名命令 (APDU)
                byte[] signCommand = buildSignAPDU(dataToSign);
                byte[] response = channel.transmit(signCommand);

                // 解析签名结果
                byte[] signature = parseSignatureResponse(response);
            }
        }
    }
});
```

**SIMKey生命周期**:

```
1. 用户首次使用:
   - 检测SIM卡是否支持安全Applet
   - 安装Chainlesschain Applet (需要运营商支持或开放式SIM卡)
   - 或使用已有的USIM安全功能

2. 初始化:
   - 设置Applet PIN (独立于SIM卡PIN)
   - 生成密钥对
   - 导出公钥存储到应用

3. 日常使用:
   - 输入PIN解锁 (或使用生物识别委托)
   - 调用签名/加密API
   - 会话超时后自动锁定

4. SIM卡更换:
   - 从备份恢复私钥到新SIM卡
   - 或生成新密钥并发布DID更新
```

## 3.3 统一认证流程

**PC端登录**:

```
1. 用户打开应用
2. 插入U盾
3. 输入PIN码 (或生物识别)
4. U盾解密本地配置文件
5. 读取DID和数据库密钥
6. 解密SQLCipher数据库
7. 加载知识库和联系人
8. 进入主界面
```

**移动端登录**:

```
1. 用户打开APP
2. 选择使用SIMKey认证
3. 输入PIN (或指纹/面容ID)
4. SIMKey解密本地配置
5. 读取DID和数据库密钥
6. 解密SQLCipher数据库
7. 后台同步Git仓库
8. 进入主界面
```

**跨设备认证** (PC与手机联动):

```
1. 用户在新PC上安装应用
2. PC显示二维码
3. 用户用手机扫码
4. 手机SIMKey签名授权消息
5. PC验证签名
6. 建立加密通道
7. 手机通过加密通道传输临时会话密钥
8. PC使用会话密钥访问云端Git仓库
9. 下载数据到PC本地
10. 用户决定是否信任此PC (写入新设备到设备列表)
```

## 3.4 加密方案

**数据加密层次**:

```
1. 存储加密 (Data at Rest)
   ├── SQLCipher数据库: AES-256-CBC
   │   └── 密钥来源: U盾/SIMKey导出的DB密钥
   │
   ├── 敏感文件: AES-256-GCM
   │   ├── 知识库文件
   │   ├── 私密照片/文档
   │   └── 聊天记录备份
   │
   └── Git仓库加密
       ├── git-crypt (透明加密)
       └── 或 git-remote-gcrypt (远程仓库加密)

2. 传输加密 (Data in Transit)
   ├── P2P通信: TLS 1.3 + Signal协议
   ├── Git同步: HTTPS + 仓库级加密
   └── API调用: TLS 1.3

3. 端到端加密 (End-to-End Encryption)
   ├── 私密消息: Signal协议
   ├── 群组消息: MLS (Messaging Layer Security)
   └── 文件传输: 接收方公钥加密
```

**加密密钥派生** (KDF):

```
Master Key (U盾/SIMKey中,256位)
    ↓ HKDF-SHA256
├── DB_Encryption_Key (数据库加密)
├── File_Encryption_Key (文件加密)
├── Backup_Encryption_Key (备份加密)
└── Transport_Key_Seed (传输密钥种子)
```


## 实现状态 (v0.20.0)

**加密技术**:
- **better-sqlite3-multiple-ciphers 12.5.0** - SQLCipher AES-256加密
- **node-forge 1.3.1** - 加密库
- **tweetnacl 1.0.3** - 现代加密
- **U盾SDK** - 硬件密钥管理(仅Windows)

**完成度**: 100% ✅ (数据库加密,密钥管理,备份恢复)

