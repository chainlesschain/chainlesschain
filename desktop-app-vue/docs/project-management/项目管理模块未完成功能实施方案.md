# é¡¹ç›®ç®¡ç†æ¨¡å—æœªå®ŒæˆåŠŸèƒ½å®æ–½æ–¹æ¡ˆ

**ç”Ÿæˆæ—¶é—´**: 2025-12-23
**å‚è€ƒæ–‡æ¡£**: ç³»ç»Ÿè®¾è®¡_ä¸ªäººç§»åŠ¨AIç®¡ç†ç³»ç»Ÿ.md (2.4èŠ‚)
**å½“å‰ç‰ˆæœ¬**: v0.17.0 (å®Œæˆåº¦87.5%)
**ç›®æ ‡ç‰ˆæœ¬**: v0.20.0 (å®Œæˆåº¦100%)

---

## ğŸ“Š å½“å‰å®Œæˆåº¦åˆ†æ

### âœ… å·²å®ŒæˆåŠŸèƒ½ (v0.17.0)
1. PPTç”Ÿæˆå¼•æ“ âœ… 100%
2. æ–‡æ¡£å¤šæ ¼å¼å¯¼å‡º âœ… 100%
3. é¡¹ç›®åˆ†äº«åŠŸèƒ½ âœ… 100%
4. æ•°æ®å¯è§†åŒ–å¼•æ“ âœ… 100%
5. AIå†…å®¹æ¶¦è‰² âœ… 100%
6. æ’­å®¢è„šæœ¬ç”Ÿæˆ âœ… 100%
7. æ–‡ç« é…å›¾ç”Ÿæˆ âœ… 100%
8. Webå¼€å‘å¼•æ“ âœ… 90%
9. æ–‡æ¡£å¤„ç†å¼•æ“ âœ… 90%
10. æ•°æ®å¤„ç†å¼•æ“ âœ… 85%
11. AIä»»åŠ¡æ‹†è§£ç³»ç»Ÿ âœ… 95%
12. é¡¹ç›®å¯¹è¯ç•Œé¢ âœ… 100%
13. æ–‡ä»¶æ ‘ç®¡ç† âœ… 100%
14. é¢„è§ˆç³»ç»Ÿ âœ… 90%

### â³ æœªå®ŒæˆåŠŸèƒ½æ¸…å•

æ ¹æ®ç³»ç»Ÿè®¾è®¡æ–‡æ¡£2.4èŠ‚,ä»¥ä¸‹åŠŸèƒ½å°šæœªå®Œå…¨å®ç°:

| åºå· | åŠŸèƒ½æ¨¡å— | è®¾è®¡æ–‡æ¡£ä½ç½® | ä¼˜å…ˆçº§ | å½“å‰çŠ¶æ€ | å®Œæˆåº¦ |
|------|---------|------------|--------|---------|--------|
| 1 | **RAGå¢å¼ºçš„é¡¹ç›®AI** | 2.4.3 | â­â­â­â­â­ | éƒ¨åˆ†å®Œæˆ | 80% |
| 2 | **è§†é¢‘å¤„ç†å¼•æ“** | 2.4.3 | â­â­â­â­ | æœªå¼€å§‹ | 0% |
| 3 | **å›¾åƒè®¾è®¡å¼•æ“** | 2.4.3 | â­â­â­â­ | æœªå¼€å§‹ | 0% |
| 4 | **ä»£ç å¼€å‘å¼•æ“** | 2.4.3 | â­â­â­â­ | æœªå¼€å§‹ | 0% |
| 5 | **é¡¹ç›®è‡ªåŠ¨åŒ–è§„åˆ™** | 2.4.4 | â­â­â­ | æœªå¼€å§‹ | 0% |
| 6 | **åä½œå®æ—¶ç¼–è¾‘** | 2.4.3 | â­â­â­ | æœªå¼€å§‹ | 0% |
| 7 | **PPTå¯è§†åŒ–ç¼–è¾‘å™¨** | è¡¥å……åŠŸèƒ½ | â­â­â­ | æœªå¼€å§‹ | 0% |
| 8 | **é¡¹ç›®æ¨¡æ¿å¸‚åœº** | 2.4.4 | â­â­ | æœªå¼€å§‹ | 0% |
| 9 | **é¡¹ç›®å•†å“åŒ–** | 2.4.3 | â­â­ | æœªå¼€å§‹ | 0% |

---

## ğŸ¯ å®æ–½ä¼˜å…ˆçº§è§„åˆ’

### Phase 1: æ ¸å¿ƒåŠŸèƒ½å®Œå–„ (v0.18.0) - 2å‘¨

**ç›®æ ‡**: å®Œæˆæœ€é«˜ä¼˜å…ˆçº§çš„æ ¸å¿ƒåŠŸèƒ½

#### 1.1 RAGå¢å¼ºçš„é¡¹ç›®AI (å‰©ä½™20%)
**å½“å‰çŠ¶æ€**: åŸºç¡€RAGé›†æˆå·²å®Œæˆ,ç¼ºå°‘é¡¹ç›®ä¸Šä¸‹æ–‡å¢å¼º

**å¾…å®ŒæˆåŠŸèƒ½**:
- [ ] é¡¹ç›®æ–‡ä»¶å‘é‡åŒ–ç´¢å¼•
- [ ] é¡¹ç›®å¯¹è¯å†å²RAGæ£€ç´¢
- [ ] å¤šæ–‡ä»¶è”åˆæ£€ç´¢
- [ ] çŸ¥è¯†åº“-é¡¹ç›®è”åˆæ£€ç´¢
- [ ] æ£€ç´¢ç»“æœé‡æ’åºä¼˜åŒ–

**æŠ€æœ¯å®ç°**:
```javascript
// æ–‡ä»¶ä½ç½®: desktop-app-vue/src/main/project/project-rag.js

class ProjectRAGManager {
  constructor() {
    this.vectorStore = null;
    this.ragManager = null;
  }

  /**
   * åˆå§‹åŒ–é¡¹ç›®RAGç³»ç»Ÿ
   */
  async initialize() {
    const { getRAGManager } = require('../rag/rag-manager');
    this.ragManager = getRAGManager();
    await this.initializeProjectVectorStore();
  }

  /**
   * ç´¢å¼•é¡¹ç›®æ–‡ä»¶
   */
  async indexProjectFiles(projectId) {
    // 1. è·å–é¡¹ç›®æ‰€æœ‰æ–‡ä»¶
    const files = await this.getProjectFiles(projectId);

    // 2. å‘é‡åŒ–æ–‡ä»¶å†…å®¹
    for (const file of files) {
      const content = await fs.readFile(file.path, 'utf-8');
      await this.ragManager.addDocument({
        id: file.id,
        content: content,
        metadata: {
          projectId: projectId,
          fileName: file.name,
          fileType: file.type,
          createdAt: file.createdAt
        }
      });
    }
  }

  /**
   * é¡¹ç›®AIå¢å¼ºæŸ¥è¯¢
   */
  async enhancedQuery(projectId, query, options = {}) {
    // 1. æ£€ç´¢é¡¹ç›®ç›¸å…³æ–‡æ¡£
    const projectDocs = await this.ragManager.search(query, {
      filter: { projectId: projectId },
      limit: 5
    });

    // 2. æ£€ç´¢çŸ¥è¯†åº“ç›¸å…³å†…å®¹
    const knowledgeDocs = await this.ragManager.search(query, {
      filter: { type: 'knowledge' },
      limit: 3
    });

    // 3. æ£€ç´¢é¡¹ç›®å¯¹è¯å†å²
    const conversationDocs = await this.searchConversationHistory(projectId, query, 3);

    // 4. åˆå¹¶å¹¶é‡æ’åº
    const allDocs = [...projectDocs, ...knowledgeDocs, ...conversationDocs];
    const rerankedDocs = await this.ragManager.rerank(query, allDocs);

    // 5. æ„å»ºå¢å¼ºçš„ä¸Šä¸‹æ–‡
    return {
      query: query,
      context: rerankedDocs,
      projectFiles: projectDocs,
      knowledgeBase: knowledgeDocs,
      conversationHistory: conversationDocs
    };
  }

  /**
   * æœç´¢å¯¹è¯å†å²
   */
  async searchConversationHistory(projectId, query, limit) {
    const db = getDatabase();
    const conversations = db.prepare(`
      SELECT * FROM project_conversations
      WHERE project_id = ? AND content LIKE ?
      ORDER BY created_at DESC LIMIT ?
    `).all(projectId, `%${query}%`, limit);

    return conversations.map(conv => ({
      content: conv.content,
      role: conv.role,
      createdAt: conv.created_at
    }));
  }
}

module.exports = ProjectRAGManager;
```

**IPCæ¥å£**:
```javascript
// desktop-app-vue/src/main/index.js

// ç´¢å¼•é¡¹ç›®æ–‡ä»¶
ipcMain.handle('project:indexFiles', async (event, projectId) => {
  const projectRAG = new ProjectRAGManager();
  await projectRAG.initialize();
  await projectRAG.indexProjectFiles(projectId);
  return { success: true };
});

// RAGå¢å¼ºæŸ¥è¯¢
ipcMain.handle('project:ragQuery', async (event, { projectId, query }) => {
  const projectRAG = new ProjectRAGManager();
  await projectRAG.initialize();
  const result = await projectRAG.enhancedQuery(projectId, query);
  return result;
});
```

---

#### 1.2 è§†é¢‘å¤„ç†å¼•æ“ (åŸºç¡€ç‰ˆ)
**åŠŸèƒ½ç›®æ ‡**: å®ç°è§†é¢‘å‰ªè¾‘ã€å­—å¹•ç”Ÿæˆã€æ ¼å¼è½¬æ¢

**æŠ€æœ¯æ ˆ**:
- FFmpeg - è§†é¢‘å¤„ç†
- moviepy - Pythonè§†é¢‘ç¼–è¾‘ (å¯é€‰)
- Whisper - AIè¯­éŸ³è¯†åˆ«å­—å¹•

**å®ç°æ–¹æ¡ˆ**:
```javascript
// æ–‡ä»¶ä½ç½®: desktop-app-vue/src/main/engines/video-engine.js

const ffmpeg = require('fluent-ffmpeg');
const path = require('path');

class VideoEngine {
  constructor() {
    this.ffmpegPath = this.findFFmpeg();
    if (this.ffmpegPath) {
      ffmpeg.setFfmpegPath(this.ffmpegPath);
    }
  }

  /**
   * æŸ¥æ‰¾ç³»ç»Ÿä¸­çš„FFmpeg
   */
  findFFmpeg() {
    // Windows
    const possiblePaths = [
      'C:\\ffmpeg\\bin\\ffmpeg.exe',
      path.join(process.env.ProgramFiles, 'ffmpeg', 'bin', 'ffmpeg.exe'),
      'ffmpeg' // å‡è®¾åœ¨PATHä¸­
    ];

    for (const p of possiblePaths) {
      if (fs.existsSync(p)) return p;
    }
    return null;
  }

  /**
   * å‰ªåˆ‡è§†é¢‘
   */
  async cutVideo(inputPath, outputPath, startTime, duration) {
    return new Promise((resolve, reject) => {
      ffmpeg(inputPath)
        .setStartTime(startTime)
        .setDuration(duration)
        .output(outputPath)
        .on('end', () => resolve({ success: true, outputPath }))
        .on('error', (err) => reject(err))
        .run();
    });
  }

  /**
   * åˆå¹¶è§†é¢‘
   */
  async mergeVideos(inputPaths, outputPath) {
    return new Promise((resolve, reject) => {
      const merger = ffmpeg();

      inputPaths.forEach(input => {
        merger.input(input);
      });

      merger
        .on('end', () => resolve({ success: true, outputPath }))
        .on('error', (err) => reject(err))
        .mergeToFile(outputPath);
    });
  }

  /**
   * è§†é¢‘æ ¼å¼è½¬æ¢
   */
  async convertFormat(inputPath, outputPath, format) {
    return new Promise((resolve, reject) => {
      ffmpeg(inputPath)
        .format(format)
        .output(outputPath)
        .on('end', () => resolve({ success: true, outputPath }))
        .on('error', (err) => reject(err))
        .run();
    });
  }

  /**
   * æå–éŸ³é¢‘
   */
  async extractAudio(videoPath, outputPath) {
    return new Promise((resolve, reject) => {
      ffmpeg(videoPath)
        .noVideo()
        .audioCodec('libmp3lame')
        .output(outputPath)
        .on('end', () => resolve({ success: true, outputPath }))
        .on('error', (err) => reject(err))
        .run();
    });
  }

  /**
   * æ·»åŠ å­—å¹• (ç¡¬å­—å¹•)
   */
  async addSubtitles(videoPath, srtPath, outputPath) {
    return new Promise((resolve, reject) => {
      ffmpeg(videoPath)
        .outputOptions([
          `-vf subtitles=${srtPath}`
        ])
        .output(outputPath)
        .on('end', () => resolve({ success: true, outputPath }))
        .on('error', (err) => reject(err))
        .run();
    });
  }

  /**
   * ç”Ÿæˆè§†é¢‘ç¼©ç•¥å›¾
   */
  async generateThumbnail(videoPath, outputPath, timestamp = '00:00:01') {
    return new Promise((resolve, reject) => {
      ffmpeg(videoPath)
        .screenshots({
          timestamps: [timestamp],
          filename: path.basename(outputPath),
          folder: path.dirname(outputPath),
          size: '320x240'
        })
        .on('end', () => resolve({ success: true, outputPath }))
        .on('error', (err) => reject(err));
    });
  }

  /**
   * AIç”Ÿæˆå­—å¹• (ä½¿ç”¨Whisper)
   *
   * @param {string} videoPath - è§†é¢‘æ–‡ä»¶è·¯å¾„
   * @param {string} language - è¯­è¨€ä»£ç  ('zh'|'en'|'ja'|'ko'ç­‰)
   * @param {Object} options - é…ç½®é€‰é¡¹
   * @param {string} options.mode - Whisperæ¨¡å¼: 'openai-api'|'local-whisper'|'llm-provider'
   *
   * ç¯å¢ƒå˜é‡é…ç½®:
   * - openai-apiæ¨¡å¼: éœ€è¦ OPENAI_API_KEY
   * - local-whisperæ¨¡å¼: éœ€è¦å®‰è£… whisper-cli æˆ– whisper.cpp
   * - llm-provideræ¨¡å¼: éœ€è¦ DASHSCOPE_API_KEY (é˜¿é‡Œäº‘)
   */
  async generateSubtitles(videoPath, language = 'zh', options = {}) {
    const { mode = 'openai-api' } = options;

    // 1. æå–éŸ³é¢‘
    const audioPath = videoPath.replace(path.extname(videoPath), '.mp3');
    await this.extractAudio(videoPath, audioPath);

    // 2. è°ƒç”¨Whisper APIæˆ–æœ¬åœ°æ¨¡å‹
    const whisperResult = await this.callWhisper(audioPath, language, mode);

    // 3. è½¬æ¢ä¸ºSRTæ ¼å¼
    const srtPath = videoPath.replace(path.extname(videoPath), '.srt');
    await this.convertToSRT(whisperResult, srtPath);

    // 4. æ¸…ç†ä¸´æ—¶éŸ³é¢‘æ–‡ä»¶ (å¯é€‰)
    // await fs.unlink(audioPath);

    return { srtPath, audioPath, segmentCount: whisperResult.segments.length };
  }

  /**
   * è°ƒç”¨Whisperè¯†åˆ«
   * æ”¯æŒä¸‰ç§æ¨¡å¼: openai-api, local-whisper, llm-provider
   */
  async callWhisper(audioPath, language, mode = 'openai-api') {
    switch (mode) {
      case 'openai-api':
        return await this.callOpenAIWhisper(audioPath, language);
      case 'local-whisper':
        return await this.callLocalWhisper(audioPath, language);
      case 'llm-provider':
        return await this.callLLMProvider(audioPath, language);
      default:
        throw new Error(`ä¸æ”¯æŒçš„Whisperæ¨¡å¼: ${mode}`);
    }
  }

  /**
   * æ–¹æ¡ˆ1: OpenAI Whisper API
   * éœ€è¦é…ç½® OPENAI_API_KEY
   */
  async callOpenAIWhisper(audioPath, language) {
    const OpenAI = require('openai');
    const fs = require('fs');

    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });

    const transcription = await openai.audio.transcriptions.create({
      file: fs.createReadStream(audioPath),
      model: 'whisper-1',
      language: language === 'zh' ? 'zh' : language,
      response_format: 'verbose_json',
      timestamp_granularities: ['segment']
    });

    return {
      segments: transcription.segments.map(seg => ({
        start: seg.start,
        end: seg.end,
        text: seg.text.trim()
      }))
    };
  }

  /**
   * æ–¹æ¡ˆ2: æœ¬åœ°Whisperæ¨¡å‹ (whisper.cpp)
   * éœ€è¦é¢„å…ˆå®‰è£… whisper-cli æˆ– whisper.cpp
   */
  async callLocalWhisper(audioPath, language) {
    const { execSync } = require('child_process');
    const fs = require('fs').promises;
    const path = require('path');

    const outputDir = path.dirname(audioPath);
    const outputJson = audioPath.replace(path.extname(audioPath), '.json');

    // è°ƒç”¨ whisper-cli (éœ€è¦é¢„å…ˆå®‰è£…)
    const cmd = `whisper "${audioPath}" --model base --language ${language} --output_format json --output_dir "${outputDir}"`;
    execSync(cmd, { encoding: 'utf-8' });

    // è¯»å–è¾“å‡ºçš„JSONæ–‡ä»¶
    const result = JSON.parse(await fs.readFile(outputJson, 'utf-8'));

    return {
      segments: result.segments.map(seg => ({
        start: seg.start,
        end: seg.end,
        text: seg.text.trim()
      }))
    };
  }

  /**
   * æ–¹æ¡ˆ3: è°ƒç”¨LLMæœåŠ¡å•†çš„è¯­éŸ³è¯†åˆ«èƒ½åŠ›
   * æ”¯æŒ: é˜¿é‡Œäº‘é€šä¹‰åƒé—®ã€è®¯é£ã€ç™¾åº¦ç­‰
   */
  async callLLMProvider(audioPath, language) {
    const fs = require('fs').promises;
    const axios = require('axios');

    // ç¤ºä¾‹: ä½¿ç”¨é˜¿é‡Œäº‘è¯­éŸ³è¯†åˆ« (éœ€é…ç½® DASHSCOPE_API_KEY)
    const audioData = await fs.readFile(audioPath);
    const base64Audio = audioData.toString('base64');

    const response = await axios.post(
      'https://dashscope.aliyuncs.com/api/v1/services/audio/asr/transcription',
      {
        model: 'paraformer-v1',
        input: {
          file_urls: [`data:audio/mp3;base64,${base64Audio}`]
        },
        parameters: {
          language_hints: [language === 'zh' ? 'zh-CN' : 'en-US']
        }
      },
      {
        headers: {
          'Authorization': `Bearer ${process.env.DASHSCOPE_API_KEY}`,
          'Content-Type': 'application/json'
        }
      }
    );

    // è§£æè¿”å›ç»“æœ
    const transcription = response.data.output;
    return {
      segments: transcription.sentences.map(sentence => ({
        start: sentence.begin_time / 1000,
        end: sentence.end_time / 1000,
        text: sentence.text.trim()
      }))
    };
  }

  /**
   * è½¬æ¢ä¸ºSRTæ ¼å¼
   */
  async convertToSRT(whisperResult, outputPath) {
    let srtContent = '';
    whisperResult.segments.forEach((seg, index) => {
      srtContent += `${index + 1}\n`;
      srtContent += `${this.formatTime(seg.start)} --> ${this.formatTime(seg.end)}\n`;
      srtContent += `${seg.text}\n\n`;
    });

    await fs.writeFile(outputPath, srtContent, 'utf-8');
  }

  /**
   * æ ¼å¼åŒ–æ—¶é—´æˆ³ (SRTæ ¼å¼)
   */
  formatTime(seconds) {
    const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
    const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
    const s = Math.floor(seconds % 60).toString().padStart(2, '0');
    const ms = Math.floor((seconds % 1) * 1000).toString().padStart(3, '0');
    return `${h}:${m}:${s},${ms}`;
  }
}

module.exports = VideoEngine;
```

**IPCæ¥å£**:
```javascript
// å‰ªåˆ‡è§†é¢‘
ipcMain.handle('project:cutVideo', async (event, { inputPath, outputPath, startTime, duration }) => {
  const videoEngine = new VideoEngine();
  return await videoEngine.cutVideo(inputPath, outputPath, startTime, duration);
});

// ç”Ÿæˆå­—å¹•
// mode: 'openai-api' | 'local-whisper' | 'llm-provider'
ipcMain.handle('project:generateSubtitles', async (event, { videoPath, language, mode }) => {
  const videoEngine = new VideoEngine();
  return await videoEngine.generateSubtitles(videoPath, language, { mode: mode || 'openai-api' });
});

// æ·»åŠ å­—å¹•
ipcMain.handle('project:addSubtitles', async (event, { videoPath, srtPath, outputPath }) => {
  const videoEngine = new VideoEngine();
  return await videoEngine.addSubtitles(videoPath, srtPath, outputPath);
});
```

---

### Phase 2: åˆ›æ„åŠŸèƒ½æ‰©å±• (v0.19.0) - 2å‘¨

#### 2.1 å›¾åƒè®¾è®¡å¼•æ“
**åŠŸèƒ½ç›®æ ‡**: AIç»˜å›¾ã€å›¾ç‰‡ç¼–è¾‘ã€æ‰¹é‡å¤„ç†

**æŠ€æœ¯æ–¹æ¡ˆ**:
```javascript
// æ–‡ä»¶ä½ç½®: desktop-app-vue/src/main/engines/image-design-engine.js

const sharp = require('sharp');
const axios = require('axios');

class ImageDesignEngine {
  constructor() {
    this.sdApiUrl = null; // Stable Diffusion API
    this.dalleApiKey = null; // DALL-E API
  }

  /**
   * AIæ–‡ç”Ÿå›¾
   */
  async textToImage(prompt, options = {}) {
    const {
      style = 'realistic',
      size = '512x512',
      apiProvider = 'sd' // 'sd' | 'dalle' | 'midjourney'
    } = options;

    if (apiProvider === 'dalle' && this.dalleApiKey) {
      return await this.callDALLE(prompt, size);
    } else if (apiProvider === 'sd' && this.sdApiUrl) {
      return await this.callStableDiffusion(prompt, size, style);
    } else {
      throw new Error('æœªé…ç½®AIç»˜å›¾API');
    }
  }

  /**
   * è°ƒç”¨Stable Diffusion
   */
  async callStableDiffusion(prompt, size, style) {
    const [width, height] = size.split('x').map(Number);

    const response = await axios.post(`${this.sdApiUrl}/sdapi/v1/txt2img`, {
      prompt: this.enhancePrompt(prompt, style),
      negative_prompt: 'low quality, blurry, distorted',
      width: width,
      height: height,
      steps: 30,
      cfg_scale: 7
    });

    // ä¿å­˜å›¾ç‰‡
    const imageBuffer = Buffer.from(response.data.images[0], 'base64');
    const outputPath = path.join(/* project path */, `ai_image_${Date.now()}.png`);
    await fs.writeFile(outputPath, imageBuffer);

    return { success: true, imagePath: outputPath };
  }

  /**
   * å¢å¼ºæç¤ºè¯
   */
  enhancePrompt(prompt, style) {
    const stylePrompts = {
      realistic: 'photorealistic, 8k, highly detailed',
      anime: 'anime style, vibrant colors, detailed illustration',
      oil_painting: 'oil painting, classical art style, rich textures',
      sketch: 'pencil sketch, black and white, artistic'
    };

    return `${prompt}, ${stylePrompts[style] || stylePrompts.realistic}`;
  }

  /**
   * èƒŒæ™¯ç§»é™¤
   */
  async removeBackground(inputPath, outputPath) {
    // ä½¿ç”¨rembgåº“æˆ–API
    // ä¸´æ—¶å®ç°: é€æ˜èƒŒæ™¯å¤„ç†
    await sharp(inputPath)
      .flatten({ background: { r: 255, g: 255, b: 255, alpha: 0 } })
      .png()
      .toFile(outputPath);

    return { success: true, outputPath };
  }

  /**
   * å›¾ç‰‡è¶…åˆ†è¾¨ç‡
   */
  async upscale(inputPath, outputPath, scale = 2) {
    const metadata = await sharp(inputPath).metadata();

    await sharp(inputPath)
      .resize(metadata.width * scale, metadata.height * scale, {
        kernel: sharp.kernel.lanczos3
      })
      .toFile(outputPath);

    return { success: true, outputPath };
  }

  /**
   * æ‰¹é‡å¤„ç†
   */
  async batchProcess(inputPaths, operation, options = {}) {
    const results = [];

    for (const inputPath of inputPaths) {
      const outputPath = this.generateOutputPath(inputPath, operation);

      try {
        let result;
        switch (operation) {
          case 'resize':
            result = await this.resize(inputPath, outputPath, options);
            break;
          case 'compress':
            result = await this.compress(inputPath, outputPath, options);
            break;
          case 'watermark':
            result = await this.addWatermark(inputPath, outputPath, options);
            break;
        }
        results.push({ success: true, outputPath });
      } catch (error) {
        results.push({ success: false, error: error.message });
      }
    }

    return results;
  }

  /**
   * å‹ç¼©å›¾ç‰‡
   */
  async compress(inputPath, outputPath, options = {}) {
    const { quality = 80, format = 'jpeg' } = options;

    await sharp(inputPath)
      .toFormat(format, { quality })
      .toFile(outputPath);

    return { success: true, outputPath };
  }

  /**
   * æ·»åŠ æ°´å°
   */
  async addWatermark(inputPath, outputPath, options = {}) {
    const { text = 'Chainlesschain', position = 'bottom-right', opacity = 0.5 } = options;

    // ç”Ÿæˆæ°´å°SVG
    const watermarkSvg = Buffer.from(`
      <svg width="200" height="50">
        <text x="10" y="30" font-family="Arial" font-size="20" fill="white" opacity="${opacity}">
          ${text}
        </text>
      </svg>
    `);

    await sharp(inputPath)
      .composite([{
        input: watermarkSvg,
        gravity: position === 'bottom-right' ? 'southeast' : 'southwest'
      }])
      .toFile(outputPath);

    return { success: true, outputPath };
  }
}

module.exports = ImageDesignEngine;
```

---

#### 2.2 ä»£ç å¼€å‘å¼•æ“
**åŠŸèƒ½ç›®æ ‡**: ä»£ç ç”Ÿæˆã€å•å…ƒæµ‹è¯•ã€ä»£ç å®¡æŸ¥

**å®ç°æ–¹æ¡ˆ**:
```javascript
// æ–‡ä»¶ä½ç½®: desktop-app-vue/src/main/engines/code-engine.js

class CodeEngine {
  constructor() {
    this.llmManager = null;
  }

  async initialize() {
    const { getLLMManager } = require('../llm/llm-manager');
    this.llmManager = getLLMManager();
  }

  /**
   * ç”Ÿæˆä»£ç 
   */
  async generateCode(description, options = {}) {
    const {
      language = 'javascript',
      framework = null,
      includeTests = false,
      includeComments = true
    } = options;

    const prompt = this.buildCodePrompt(description, language, framework, includeComments);

    const response = await this.llmManager.query(prompt, {
      temperature: 0.3, // ä»£ç ç”Ÿæˆä½¿ç”¨ä½æ¸©åº¦
      maxTokens: 2000
    });

    // æå–ä»£ç å—
    const code = this.extractCodeBlock(response);

    // ç”Ÿæˆå•å…ƒæµ‹è¯•
    let tests = null;
    if (includeTests) {
      tests = await this.generateTests(code, language);
    }

    return {
      code: code,
      tests: tests,
      language: language,
      framework: framework
    };
  }

  /**
   * æ„å»ºä»£ç ç”Ÿæˆæç¤ºè¯
   */
  buildCodePrompt(description, language, framework, includeComments) {
    let prompt = `è¯·ç”¨${language}è¯­è¨€`;

    if (framework) {
      prompt += `å’Œ${framework}æ¡†æ¶`;
    }

    prompt += `å®ç°ä»¥ä¸‹åŠŸèƒ½:\n\n${description}\n\n`;

    if (includeComments) {
      prompt += 'è¯·åŒ…å«è¯¦ç»†çš„æ³¨é‡Šã€‚\n';
    }

    prompt += `
è¦æ±‚:
1. ä»£ç è¦æ¸…æ™°ã€ç®€æ´ã€å¯ç»´æŠ¤
2. éµå¾ª${language}çš„æœ€ä½³å®è·µ
3. å¤„ç†å¯èƒ½çš„é”™è¯¯æƒ…å†µ
4. ä½¿ç”¨ç°ä»£è¯­æ³•ç‰¹æ€§

è¯·åªè¾“å‡ºä»£ç ,ç”¨\`\`\`${language}ä»£ç å—åŒ…è£¹ã€‚
`;

    return prompt;
  }

  /**
   * æå–ä»£ç å—
   */
  extractCodeBlock(text) {
    const codeBlockRegex = /```(?:\w+)?\n([\s\S]*?)```/g;
    const matches = [...text.matchAll(codeBlockRegex)];

    if (matches.length > 0) {
      return matches[0][1].trim();
    }

    return text.trim();
  }

  /**
   * ç”Ÿæˆå•å…ƒæµ‹è¯•
   */
  async generateTests(code, language) {
    const testFrameworks = {
      javascript: 'Jest',
      python: 'pytest',
      java: 'JUnit',
      go: 'testing'
    };

    const framework = testFrameworks[language] || 'standard';

    const prompt = `
ä¸ºä»¥ä¸‹${language}ä»£ç ç¼–å†™å®Œæ•´çš„å•å…ƒæµ‹è¯•,ä½¿ç”¨${framework}æ¡†æ¶:

\`\`\`${language}
${code}
\`\`\`

è¦æ±‚:
1. è¦†ç›–ä¸»è¦åŠŸèƒ½
2. åŒ…å«è¾¹ç•Œæƒ…å†µæµ‹è¯•
3. æµ‹è¯•é”™è¯¯å¤„ç†
4. ä½¿ç”¨æ¸…æ™°çš„æµ‹è¯•åç§°

è¯·åªè¾“å‡ºæµ‹è¯•ä»£ç ,ç”¨\`\`\`${language}ä»£ç å—åŒ…è£¹ã€‚
`;

    const response = await this.llmManager.query(prompt, {
      temperature: 0.3,
      maxTokens: 1500
    });

    return this.extractCodeBlock(response);
  }

  /**
   * ä»£ç å®¡æŸ¥
   */
  async reviewCode(code, language) {
    const prompt = `
è¯·å®¡æŸ¥ä»¥ä¸‹${language}ä»£ç ,æä¾›æ”¹è¿›å»ºè®®:

\`\`\`${language}
${code}
\`\`\`

è¯·ä»ä»¥ä¸‹æ–¹é¢è¯„ä¼°:
1. ä»£ç è´¨é‡å’Œå¯è¯»æ€§
2. æ€§èƒ½é—®é¢˜
3. å®‰å…¨éšæ‚£
4. æ½œåœ¨bug
5. æœ€ä½³å®è·µå»ºè®®

è¯·ç»™å‡ºå…·ä½“çš„æ”¹è¿›å»ºè®®å’Œä¿®æ”¹åçš„ä»£ç ã€‚
`;

    const response = await this.llmManager.query(prompt, {
      temperature: 0.5,
      maxTokens: 2000
    });

    return {
      review: response,
      suggestions: this.parseReviewSuggestions(response)
    };
  }

  /**
   * è§£æå®¡æŸ¥å»ºè®®
   */
  parseReviewSuggestions(review) {
    // ç®€å•å®ç°:æå–ç¼–å·åˆ—è¡¨
    const lines = review.split('\n');
    const suggestions = [];

    for (const line of lines) {
      const match = line.match(/^\d+\.\s*(.+)/);
      if (match) {
        suggestions.push(match[1]);
      }
    }

    return suggestions;
  }

  /**
   * ä»£ç é‡æ„
   */
  async refactorCode(code, language, refactoringType) {
    const refactoringPrompts = {
      'extract_function': 'æå–é‡å¤ä»£ç ä¸ºå‡½æ•°',
      'rename_variables': 'æ”¹è¿›å˜é‡å‘½å',
      'simplify': 'ç®€åŒ–å¤æ‚é€»è¾‘',
      'optimize': 'ä¼˜åŒ–æ€§èƒ½'
    };

    const prompt = `
è¯·å¯¹ä»¥ä¸‹${language}ä»£ç è¿›è¡Œé‡æ„: ${refactoringPrompts[refactoringType]}

åŸå§‹ä»£ç :
\`\`\`${language}
${code}
\`\`\`

è¦æ±‚:
1. ä¿æŒåŠŸèƒ½ä¸å˜
2. æé«˜ä»£ç è´¨é‡
3. æ·»åŠ å¿…è¦çš„æ³¨é‡Š
4. è¯´æ˜é‡æ„çš„åŸå› 

è¯·è¾“å‡ºé‡æ„åçš„ä»£ç å’Œè¯´æ˜ã€‚
`;

    const response = await this.llmManager.query(prompt, {
      temperature: 0.3,
      maxTokens: 2000
    });

    const refactoredCode = this.extractCodeBlock(response);

    return {
      originalCode: code,
      refactoredCode: refactoredCode,
      explanation: response
    };
  }

  /**
   * ç”Ÿæˆé¡¹ç›®è„šæ‰‹æ¶
   */
  async generateScaffold(projectType, options = {}) {
    const templates = {
      'express_api': {
        files: [
          { name: 'app.js', content: this.getExpressAppTemplate() },
          { name: 'package.json', content: this.getPackageJsonTemplate('express') },
          { name: '.gitignore', content: this.getGitignoreTemplate() }
        ]
      },
      'react_app': {
        files: [
          // Reacté¡¹ç›®æ–‡ä»¶
        ]
      }
    };

    return templates[projectType] || { files: [] };
  }

  /**
   * Expressåº”ç”¨æ¨¡æ¿
   */
  getExpressAppTemplate() {
    return `
const express = require('express');
const app = express();
const port = process.env.PORT || 3000;

app.use(express.json());

app.get('/', (req, res) => {
  res.json({ message: 'Hello World!' });
});

app.listen(port, () => {
  console.log(\`Server running on port \${port}\`);
});

module.exports = app;
`.trim();
  }
}

module.exports = CodeEngine;
```

---

### Phase 3: é«˜çº§åŠŸèƒ½ (v0.20.0) - 2å‘¨

#### 3.1 é¡¹ç›®è‡ªåŠ¨åŒ–è§„åˆ™
**åŠŸèƒ½ç›®æ ‡**: å®šæ—¶ä»»åŠ¡ã€è§¦å‘å™¨ã€å·¥ä½œæµè‡ªåŠ¨åŒ–

**æ•°æ®åº“è¡¨** (å·²åœ¨ç³»ç»Ÿè®¾è®¡ä¸­å®šä¹‰):
```sql
CREATE TABLE project_automation_rules (
    id TEXT PRIMARY KEY,
    project_id TEXT NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    trigger_type TEXT NOT NULL,  -- 'schedule', 'file_change', 'task_complete', 'manual'
    trigger_config TEXT NOT NULL,  -- JSONé…ç½®
    action_type TEXT NOT NULL,  -- 'run_task', 'generate_report', 'send_notification', 'git_commit'
    action_config TEXT NOT NULL,  -- JSONé…ç½®
    is_enabled INTEGER DEFAULT 1,
    last_run_at INTEGER,
    next_run_at INTEGER,
    created_at INTEGER NOT NULL,
    FOREIGN KEY (project_id) REFERENCES projects(id)
);
```

**å®ç°æ–¹æ¡ˆ**:
```javascript
// æ–‡ä»¶ä½ç½®: desktop-app-vue/src/main/project/automation-manager.js

const cron = require('node-cron');
const chokidar = require('chokidar');

class AutomationManager {
  constructor() {
    this.rules = new Map();
    this.scheduledTasks = new Map();
    this.fileWatchers = new Map();
  }

  /**
   * åŠ è½½é¡¹ç›®çš„è‡ªåŠ¨åŒ–è§„åˆ™
   */
  async loadProjectRules(projectId) {
    const db = getDatabase();
    const rules = db.prepare(`
      SELECT * FROM project_automation_rules
      WHERE project_id = ? AND is_enabled = 1
    `).all(projectId);

    for (const rule of rules) {
      await this.registerRule(rule);
    }
  }

  /**
   * æ³¨å†Œè‡ªåŠ¨åŒ–è§„åˆ™
   */
  async registerRule(rule) {
    const { id, trigger_type, trigger_config, action_type, action_config } = rule;

    switch (trigger_type) {
      case 'schedule':
        this.registerScheduledTask(id, trigger_config, action_type, action_config);
        break;
      case 'file_change':
        this.registerFileWatcher(id, trigger_config, action_type, action_config);
        break;
      case 'task_complete':
        // é€šè¿‡äº‹ä»¶ç›‘å¬å®ç°
        break;
    }

    this.rules.set(id, rule);
  }

  /**
   * æ³¨å†Œå®šæ—¶ä»»åŠ¡
   */
  registerScheduledTask(ruleId, triggerConfig, actionType, actionConfig) {
    const config = JSON.parse(triggerConfig);
    const cronExpression = config.cron; // å¦‚ '0 9 * * *' (æ¯å¤©9ç‚¹)

    const task = cron.schedule(cronExpression, async () => {
      console.log(`[Automation] æ‰§è¡Œå®šæ—¶ä»»åŠ¡: ${ruleId}`);
      await this.executeAction(actionType, JSON.parse(actionConfig));

      // æ›´æ–°æœ€åæ‰§è¡Œæ—¶é—´
      this.updateLastRun(ruleId);
    });

    this.scheduledTasks.set(ruleId, task);
  }

  /**
   * æ³¨å†Œæ–‡ä»¶ç›‘å¬
   */
  registerFileWatcher(ruleId, triggerConfig, actionType, actionConfig) {
    const config = JSON.parse(triggerConfig);
    const watchPath = config.path;
    const pattern = config.pattern || '*.*';

    const watcher = chokidar.watch(path.join(watchPath, pattern), {
      persistent: true,
      ignoreInitial: true
    });

    watcher.on('change', async (filePath) => {
      console.log(`[Automation] æ–‡ä»¶å˜åŒ–è§¦å‘: ${filePath}`);
      await this.executeAction(actionType, JSON.parse(actionConfig));
      this.updateLastRun(ruleId);
    });

    this.fileWatchers.set(ruleId, watcher);
  }

  /**
   * æ‰§è¡ŒåŠ¨ä½œ
   */
  async executeAction(actionType, actionConfig) {
    switch (actionType) {
      case 'run_task':
        await this.runTask(actionConfig);
        break;
      case 'generate_report':
        await this.generateReport(actionConfig);
        break;
      case 'send_notification':
        await this.sendNotification(actionConfig);
        break;
      case 'git_commit':
        await this.gitCommit(actionConfig);
        break;
    }
  }

  /**
   * æ‰§è¡Œä»»åŠ¡
   */
  async runTask(config) {
    const { taskDescription, projectId } = config;

    // è°ƒç”¨AIå¼•æ“å¤„ç†ä»»åŠ¡
    const aiEngine = require('../ai-engine/ai-engine-manager');
    await aiEngine.processUserInput(taskDescription, { projectId });
  }

  /**
   * ç”ŸæˆæŠ¥å‘Š
   */
  async generateReport(config) {
    const { reportType, projectId, outputPath } = config;

    // æ ¹æ®ç±»å‹ç”Ÿæˆä¸åŒæŠ¥å‘Š
    // ä¾‹å¦‚:æ¯æ—¥è¿›åº¦æŠ¥å‘Šã€å‘¨æŠ¥ã€æ•°æ®åˆ†ææŠ¥å‘Šç­‰
  }

  /**
   * å‘é€é€šçŸ¥
   */
  async sendNotification(config) {
    const { title, message, channels } = config;

    // å‘é€åˆ°ä¸åŒæ¸ é“:æ¡Œé¢é€šçŸ¥ã€é‚®ä»¶ã€webhookç­‰
    const { Notification } = require('electron');

    new Notification({
      title: title,
      body: message
    }).show();
  }

  /**
   * Gitæäº¤
   */
  async gitCommit(config) {
    const { projectPath, commitMessage } = config;

    const gitManager = require('../git/git-manager');
    await gitManager.autoCommit(projectPath, commitMessage);
  }

  /**
   * æ›´æ–°æœ€åæ‰§è¡Œæ—¶é—´
   */
  updateLastRun(ruleId) {
    const db = getDatabase();
    db.prepare(`
      UPDATE project_automation_rules
      SET last_run_at = ?,
          next_run_at = ?
      WHERE id = ?
    `).run(Date.now(), this.calculateNextRun(ruleId), ruleId);
  }

  /**
   * åœæ­¢è§„åˆ™
   */
  stopRule(ruleId) {
    if (this.scheduledTasks.has(ruleId)) {
      this.scheduledTasks.get(ruleId).stop();
      this.scheduledTasks.delete(ruleId);
    }

    if (this.fileWatchers.has(ruleId)) {
      this.fileWatchers.get(ruleId).close();
      this.fileWatchers.delete(ruleId);
    }

    this.rules.delete(ruleId);
  }
}

module.exports = AutomationManager;
```

---

#### 3.2 åä½œå®æ—¶ç¼–è¾‘
**åŠŸèƒ½ç›®æ ‡**: WebSocketå®æ—¶åŒæ­¥ã€OTç®—æ³•å†²çªè§£å†³

**æŠ€æœ¯æ ˆ**:
- Socket.IO - WebSocketé€šä¿¡
- ShareDB - å®æ—¶åä½œæ¡†æ¶
- OTç®—æ³• - æ“ä½œè½¬æ¢

**å®ç°æ–¹æ¡ˆ**:
```javascript
// æ–‡ä»¶ä½ç½®: desktop-app-vue/src/main/collaboration/collab-manager.js

const io = require('socket.io');
const ShareDB = require('sharedb');
const WebSocket = require('ws');

class CollaborationManager {
  constructor() {
    this.sharedb = new ShareDB();
    this.wss = null;
    this.connections = new Map();
  }

  /**
   * å¯åŠ¨åä½œæœåŠ¡å™¨
   */
  startServer(port = 8080) {
    this.wss = new WebSocket.Server({ port });

    this.wss.on('connection', (ws) => {
      const connectionId = this.generateConnectionId();
      console.log(`[Collab] æ–°è¿æ¥: ${connectionId}`);

      const stream = new WebSocket.Stream(ws);
      this.sharedb.listen(stream);

      this.connections.set(connectionId, {
        ws: ws,
        stream: stream,
        userId: null,
        projectId: null
      });

      ws.on('close', () => {
        console.log(`[Collab] è¿æ¥å…³é—­: ${connectionId}`);
        this.connections.delete(connectionId);
      });
    });

    console.log(`[Collab] åä½œæœåŠ¡å™¨å¯åŠ¨åœ¨ç«¯å£ ${port}`);
  }

  /**
   * åŠ å…¥é¡¹ç›®åä½œ
   */
  async joinProject(userId, projectId) {
    const connection = this.sharedb.connection;
    const doc = connection.get('projects', projectId);

    await new Promise((resolve, reject) => {
      doc.fetch((err) => {
        if (err) return reject(err);

        if (!doc.type) {
          // æ–‡æ¡£ä¸å­˜åœ¨,åˆ›å»ºæ–°æ–‡æ¡£
          doc.create({ content: '', version: 0 }, (err) => {
            if (err) return reject(err);
            resolve();
          });
        } else {
          resolve();
        }
      });
    });

    // è®¢é˜…æ–‡æ¡£å˜æ›´
    doc.subscribe();

    return doc;
  }

  /**
   * å‘é€ç¼–è¾‘æ“ä½œ
   */
  async submitOp(projectId, op) {
    const doc = this.sharedb.connection.get('projects', projectId);

    return new Promise((resolve, reject) => {
      doc.submitOp(op, (err) => {
        if (err) return reject(err);
        resolve();
      });
    });
  }

  /**
   * ç›‘å¬æ–‡æ¡£å˜æ›´
   */
  onDocChange(projectId, callback) {
    const doc = this.sharedb.connection.get('projects', projectId);

    doc.on('op', (op, source) => {
      if (!source) { // æ¥è‡ªå…¶ä»–å®¢æˆ·ç«¯çš„æ“ä½œ
        callback(op);
      }
    });
  }

  /**
   * å¹¿æ’­å…‰æ ‡ä½ç½®
   */
  broadcastCursor(projectId, userId, position) {
    this.connections.forEach((conn) => {
      if (conn.projectId === projectId && conn.userId !== userId) {
        conn.ws.send(JSON.stringify({
          type: 'cursor',
          userId: userId,
          position: position
        }));
      }
    });
  }

  /**
   * è·å–åœ¨çº¿ç”¨æˆ·
   */
  getOnlineUsers(projectId) {
    const users = [];

    this.connections.forEach((conn) => {
      if (conn.projectId === projectId && conn.userId) {
        users.push({
          userId: conn.userId,
          // å…¶ä»–ç”¨æˆ·ä¿¡æ¯
        });
      }
    });

    return users;
  }
}

module.exports = CollaborationManager;
```

---

## ğŸ—“ï¸ å®æ–½æ—¶é—´è¡¨

### Week 1-2: Phase 1 æ ¸å¿ƒåŠŸèƒ½å®Œå–„
- **Day 1-3**: RAGå¢å¼ºçš„é¡¹ç›®AI (å®Œæˆå‰©ä½™20%)
- **Day 4-7**: è§†é¢‘å¤„ç†å¼•æ“åŸºç¡€åŠŸèƒ½
- **Day 8-10**: æµ‹è¯•å’Œä¼˜åŒ–

### Week 3-4: Phase 2 åˆ›æ„åŠŸèƒ½æ‰©å±•
- **Day 11-14**: å›¾åƒè®¾è®¡å¼•æ“
- **Day 15-18**: ä»£ç å¼€å‘å¼•æ“
- **Day 19-20**: é›†æˆæµ‹è¯•

### Week 5-6: Phase 3 é«˜çº§åŠŸèƒ½
- **Day 21-24**: é¡¹ç›®è‡ªåŠ¨åŒ–è§„åˆ™
- **Day 25-28**: åä½œå®æ—¶ç¼–è¾‘
- **Day 29-30**: å…¨é¢æµ‹è¯•å’Œæ–‡æ¡£

---

## ğŸ“¦ ä¾èµ–åŒ…æ¸…å•

### æ–°å¢NPMåŒ…
```json
{
  "dependencies": {
    "fluent-ffmpeg": "^2.1.2",      // è§†é¢‘å¤„ç†
    "node-cron": "^3.0.2",          // å®šæ—¶ä»»åŠ¡
    "chokidar": "^3.5.3",           // æ–‡ä»¶ç›‘å¬
    "socket.io": "^4.6.0",          // WebSocket
    "sharedb": "^3.0.0",            // åä½œç¼–è¾‘
    "ws": "^8.13.0",                // WebSocketå®¢æˆ·ç«¯
    "axios": "^1.4.0"               // HTTPè¯·æ±‚
  },
  "optionalDependencies": {
    "puppeteer": "^21.0.0"          // PDFç”Ÿæˆ(å¯é€‰)
  }
}
```

### ç³»ç»Ÿä¾èµ–
- **FFmpeg**: è§†é¢‘å¤„ç†å¿…éœ€
- **Whisper**: AIå­—å¹•ç”Ÿæˆ(å¯é€‰)
- **Stable Diffusion**: AIç»˜å›¾(å¯é€‰,éœ€è¦ç‹¬ç«‹éƒ¨ç½²)

---

## ğŸ§ª æµ‹è¯•è®¡åˆ’

### åŠŸèƒ½æµ‹è¯•æ¸…å•
- [ ] RAGå¢å¼ºæŸ¥è¯¢å‡†ç¡®æ€§æµ‹è¯•
- [ ] è§†é¢‘å‰ªè¾‘å’Œå­—å¹•ç”Ÿæˆæµ‹è¯•
- [ ] AIç»˜å›¾åŠŸèƒ½æµ‹è¯•
- [ ] ä»£ç ç”Ÿæˆè´¨é‡è¯„ä¼°
- [ ] è‡ªåŠ¨åŒ–è§„åˆ™è§¦å‘æµ‹è¯•
- [ ] åä½œç¼–è¾‘å†²çªè§£å†³æµ‹è¯•

### æ€§èƒ½æµ‹è¯•
- [ ] å¤§æ–‡ä»¶è§†é¢‘å¤„ç†æ€§èƒ½
- [ ] é«˜å¹¶å‘åä½œç¼–è¾‘æ€§èƒ½
- [ ] RAGæŸ¥è¯¢å“åº”æ—¶é—´
- [ ] è‡ªåŠ¨åŒ–è§„åˆ™èµ„æºå ç”¨

---

## ğŸ“Š é¢„æœŸæˆæœ

### v0.20.0 ç‰ˆæœ¬ç›®æ ‡
- **åŠŸèƒ½å®Œæ•´åº¦**: 100%
- **é¡¹ç›®ç®¡ç†æ¨¡å—**: å®Œå…¨å®ç°ç³»ç»Ÿè®¾è®¡æ–‡æ¡£2.4èŠ‚æ‰€æœ‰åŠŸèƒ½
- **ç”¨æˆ·æ»¡æ„åº¦**: è¾¾åˆ°ç”Ÿäº§å¯ç”¨çº§åˆ«
- **ä»£ç è´¨é‡**: é€šè¿‡æ‰€æœ‰å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [ç³»ç»Ÿè®¾è®¡æ–‡æ¡£](./ç³»ç»Ÿè®¾è®¡_ä¸ªäººç§»åŠ¨AIç®¡ç†ç³»ç»Ÿ.md) - 2.4èŠ‚é¡¹ç›®ç®¡ç†æ¨¡å—
- [é¡¹ç›®ç®¡ç†æ¨¡å—è¡¥å®Œå®æ–½å®ŒæˆæŠ¥å‘Š](./desktop-app-vue/docs/é¡¹ç›®ç®¡ç†æ¨¡å—è¡¥å®Œå®æ–½å®ŒæˆæŠ¥å‘Š-2025-12-23.md)
- [æ–°å¢åŠŸèƒ½å¿«é€Ÿä½¿ç”¨æŒ‡å—](./desktop-app-vue/docs/æ–°å¢åŠŸèƒ½å¿«é€Ÿä½¿ç”¨æŒ‡å—-2025-12-23.md)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**ç”Ÿæˆæ—¶é—´**: 2025-12-23
**é¢„è®¡å®Œæˆæ—¶é—´**: 2026-02-28 (6å‘¨)
