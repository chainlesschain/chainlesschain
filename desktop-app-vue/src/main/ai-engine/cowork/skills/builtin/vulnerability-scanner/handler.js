/**
 * Vulnerability Scanner Skill Handler
 *
 * Scans npm dependencies for CVEs via npm audit, checks license compatibility,
 * and generates SBOM (Software Bill of Materials).
 */

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");
const { logger } = require("../../../../../utils/logger.js");

module.exports = {
  async init(skill) {
    logger.info("[VulnerabilityScanner] Handler initialized");
  },

  async execute(task, context = {}, skill) {
    const input = task.input || task.args || "";
    const { action, options } = parseInput(input, context);

    logger.info(`[VulnerabilityScanner] Action: ${action}`, { options });

    try {
      switch (action) {
        case "scan":
          return await handleScan(options.targetDir);
        case "sbom":
          return await handleSBOM(options.targetDir, options.format);
        case "licenses":
          return await handleLicenses(options.targetDir);
        default:
          return await handleScan(options.targetDir);
      }
    } catch (error) {
      logger.error(`[VulnerabilityScanner] Error: ${error.message}`);
      return {
        success: false,
        error: error.message,
        message: `Vulnerability scan failed: ${error.message}`,
      };
    }
  },
};

function parseInput(input, context) {
  const parts = (input || "").trim().split(/\s+/);
  const options = {
    targetDir: context.workspacePath || process.cwd(),
    format: "cyclonedx",
  };
  let action = "scan";

  for (let i = 0; i < parts.length; i++) {
    const p = parts[i];
    if (p === "--sbom") {
      action = "sbom";
    } else if (p === "--licenses") {
      action = "licenses";
    } else if (p === "--format") {
      options.format = parts[++i] || "cyclonedx";
    } else if (p === "--reachability") {
      options.reachability = true;
    } else if (p && !p.startsWith("-")) {
      const resolved = path.resolve(options.targetDir, p);
      if (fs.existsSync(resolved) && fs.statSync(resolved).isDirectory()) {
        options.targetDir = resolved;
      }
    }
  }

  return { action, options };
}

function runNpmAudit(targetDir) {
  try {
    const output = execSync("npm audit --json 2>/dev/null", {
      encoding: "utf-8",
      cwd: targetDir,
      timeout: 30000,
      stdio: ["pipe", "pipe", "pipe"],
    });
    return JSON.parse(output);
  } catch (err) {
    // npm audit exits non-zero when vulnerabilities exist
    if (err.stdout) {
      try {
        return JSON.parse(err.stdout);
      } catch {
        /* fall through */
      }
    }
    return null;
  }
}

function readPackageLock(targetDir) {
  const lockPath = path.join(targetDir, "package-lock.json");
  if (!fs.existsSync(lockPath)) {
    return null;
  }
  try {
    return JSON.parse(fs.readFileSync(lockPath, "utf-8"));
  } catch {
    return null;
  }
}

function readPackageJson(targetDir) {
  const pkgPath = path.join(targetDir, "package.json");
  if (!fs.existsSync(pkgPath)) {
    return null;
  }
  try {
    return JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
  } catch {
    return null;
  }
}

async function handleScan(targetDir) {
  const audit = runNpmAudit(targetDir);
  if (!audit) {
    return {
      success: false,
      message: "npm audit failed. Ensure package-lock.json exists.",
    };
  }

  const vulns = audit.vulnerabilities || {};
  const metadata = audit.metadata || {};

  const vulnList = Object.entries(vulns).map(([pkg, info]) => ({
    package: pkg,
    severity: info.severity || "unknown",
    title: info.title || "",
    via: Array.isArray(info.via)
      ? info.via
          .map((v) => (typeof v === "string" ? v : v.title || v.name || ""))
          .filter(Boolean)
      : [],
    fixAvailable: !!info.fixAvailable,
    range: info.range || "",
  }));

  const bySeverity = { critical: 0, high: 0, moderate: 0, low: 0, info: 0 };
  for (const v of vulnList) {
    if (bySeverity[v.severity] !== undefined) {
      bySeverity[v.severity]++;
    }
  }

  const sorted = vulnList.sort((a, b) => {
    const order = {
      critical: 0,
      high: 1,
      moderate: 2,
      low: 3,
      info: 4,
      unknown: 5,
    };
    return (order[a.severity] || 5) - (order[b.severity] || 5);
  });

  // Generate fix command
  const fixable = sorted.filter((v) => v.fixAvailable);
  const fixCmd = fixable.length > 0 ? `npm audit fix` : null;

  const report =
    `Vulnerability Scan Report\n${"=".repeat(30)}\n` +
    `Dependencies: ${metadata.dependencies?.total || "unknown"}\n` +
    `Vulnerabilities: ${vulnList.length}\n` +
    `  Critical: ${bySeverity.critical}, High: ${bySeverity.high}, Moderate: ${bySeverity.moderate}, Low: ${bySeverity.low}\n\n` +
    (sorted.length > 0
      ? sorted
          .slice(0, 40)
          .map((v) => {
            const icon =
              v.severity === "critical"
                ? "ðŸ”´"
                : v.severity === "high"
                  ? "ðŸŸ "
                  : v.severity === "moderate"
                    ? "ðŸŸ¡"
                    : "ðŸ”µ";
            return `${icon} ${v.severity.toUpperCase()} ${v.package}${v.fixAvailable ? " (fix available)" : ""}\n   ${v.via.join(", ")}`;
          })
          .join("\n")
      : "No vulnerabilities found.") +
    (fixCmd ? `\n\nRemediation:\n  ${fixCmd}` : "");

  return {
    success: true,
    result: {
      vulnerabilities: vulnList,
      bySeverity,
      fixableCount: fixable.length,
    },
    message: report,
  };
}

async function handleSBOM(targetDir, format) {
  const pkg = readPackageJson(targetDir);
  const lockData = readPackageLock(targetDir);

  if (!pkg) {
    return { success: false, message: "package.json not found." };
  }

  const components = [];
  const deps = { ...pkg.dependencies };
  const devDeps = { ...pkg.devDependencies };

  // Read actual installed versions from node_modules
  const nmDir = path.join(targetDir, "node_modules");
  let scanned = 0;

  if (fs.existsSync(nmDir)) {
    let entries;
    try {
      entries = fs.readdirSync(nmDir, { withFileTypes: true });
    } catch {
      entries = [];
    }

    for (const entry of entries) {
      if (!entry.isDirectory() || entry.name.startsWith(".")) {
        continue;
      }
      const depPkgPath = path.join(nmDir, entry.name, "package.json");
      if (!fs.existsSync(depPkgPath)) {
        continue;
      }

      try {
        const depPkg = JSON.parse(fs.readFileSync(depPkgPath, "utf-8"));
        components.push({
          name: depPkg.name || entry.name,
          version: depPkg.version || "unknown",
          license: depPkg.license || "UNKNOWN",
          type: deps[entry.name]
            ? "dependency"
            : devDeps[entry.name]
              ? "devDependency"
              : "transitive",
        });
        scanned++;
      } catch {
        /* skip */
      }

      if (scanned >= 500) {
        break;
      }
    }
  }

  const sbom = {
    bomFormat: format === "spdx" ? "SPDX" : "CycloneDX",
    specVersion: format === "spdx" ? "2.3" : "1.4",
    metadata: {
      component: { name: pkg.name, version: pkg.version },
      timestamp: new Date().toISOString(),
    },
    components: components.slice(0, 200),
    totalComponents: components.length,
  };

  const report =
    `SBOM Generated (${sbom.bomFormat})\n${"=".repeat(30)}\n` +
    `Project: ${pkg.name}@${pkg.version}\n` +
    `Components: ${components.length}\n` +
    `  Dependencies: ${components.filter((c) => c.type === "dependency").length}\n` +
    `  DevDependencies: ${components.filter((c) => c.type === "devDependency").length}\n` +
    `  Transitive: ${components.filter((c) => c.type === "transitive").length}\n\n` +
    `Top licenses:\n` +
    Object.entries(
      components.reduce((acc, c) => {
        acc[c.license] = (acc[c.license] || 0) + 1;
        return acc;
      }, {}),
    )
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10)
      .map(([lic, count]) => `  ${lic}: ${count}`)
      .join("\n");

  return {
    success: true,
    result: sbom,
    message: report,
  };
}

async function handleLicenses(targetDir) {
  const nmDir = path.join(targetDir, "node_modules");
  if (!fs.existsSync(nmDir)) {
    return {
      success: false,
      message: "node_modules not found. Run npm install first.",
    };
  }

  const licenses = {};
  const gplPackages = [];
  let scanned = 0;

  let entries;
  try {
    entries = fs.readdirSync(nmDir, { withFileTypes: true });
  } catch {
    return { success: false, message: "Cannot read node_modules." };
  }

  for (const entry of entries) {
    if (!entry.isDirectory() || entry.name.startsWith(".")) {
      continue;
    }
    const pkgPath = path.join(nmDir, entry.name, "package.json");
    if (!fs.existsSync(pkgPath)) {
      continue;
    }

    try {
      const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
      const license = pkg.license || "UNKNOWN";
      licenses[license] = (licenses[license] || 0) + 1;

      if (/GPL/i.test(license) && !/LGPL/i.test(license)) {
        gplPackages.push({ name: entry.name, license });
      }
      scanned++;
    } catch {
      /* skip */
    }

    if (scanned >= 600) {
      break;
    }
  }

  const sorted = Object.entries(licenses).sort(([, a], [, b]) => b - a);

  const report =
    `License Audit Report\n${"=".repeat(25)}\n` +
    `Packages scanned: ${scanned}\n` +
    `License types: ${sorted.length}\n\n` +
    sorted
      .map(([lic, count]) => {
        const warn =
          /GPL/i.test(lic) && !/LGPL/i.test(lic) ? " âš ï¸ COPYLEFT" : "";
        return `  ${lic}: ${count}${warn}`;
      })
      .join("\n") +
    (gplPackages.length > 0
      ? `\n\nâš ï¸ GPL Warning:\n` +
        `The following packages use GPL licenses which may require your code to be open-sourced:\n` +
        gplPackages.map((p) => `  - ${p.name} (${p.license})`).join("\n")
      : "\n\nâœ… No copyleft license issues detected.");

  return {
    success: true,
    result: { licenses, gplPackages, scanned },
    message: report,
  };
}
