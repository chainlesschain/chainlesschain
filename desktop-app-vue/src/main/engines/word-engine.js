/**
 * Word文档处理引擎
 * 提供Word文档的读取、写入、编辑和转换功能
 * 支持 .docx 格式
 */

const nodeFs = require('fs');
const path = require('path');
const { getFileHandler } = require('../utils/file-handler');

const globalContext =
  typeof globalThis !== 'undefined'
    ? globalThis
    : typeof global !== 'undefined'
      ? global
      : undefined;
const docxModule =
  (globalContext && globalContext.__WORD_ENGINE_DOCX__) || require('docx');
const {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  AlignmentType,
  UnderlineType,
} = docxModule;

const mammothModule =
  (globalContext && globalContext.__WORD_ENGINE_MAMMOTH__) || require('mammoth');
const mammoth = mammothModule.default || mammothModule;

const markedModule =
  (globalContext && globalContext.__WORD_ENGINE_MARKED__) || require('marked');
const marked = markedModule.marked || markedModule;

const fs = (globalContext && globalContext.__WORD_ENGINE_FS__) || nodeFs.promises;

const resolveFileHandler = () => {
  if (globalContext && globalContext.__WORD_ENGINE_FILE_HANDLER__) {
    return globalContext.__WORD_ENGINE_FILE_HANDLER__;
  }
  return getFileHandler();
};

class WordEngine {
  constructor() {
    this.supportedFormats = ['.docx', '.doc'];
    this.fileHandler = resolveFileHandler();
  }

  /**
   * 读取Word文档
   * @param {string} filePath - 文件路径
   * @returns {Promise<Object>} 文档内容
   */
  async readWord(filePath) {
    try {
      console.log('[WordEngine] 读取Word文档:', filePath);

      // 检查文件大小
      const fileSize = await this.fileHandler.getFileSize(filePath);
      const isLarge = fileSize > 10 * 1024 * 1024; // 10MB

      if (isLarge) {
        console.log(`[WordEngine] 检测到大文件 (${(fileSize / 1024 / 1024).toFixed(2)}MB)，使用优化模式`);
      }

      // 检查内存可用性
      const memStatus = this.fileHandler.checkAvailableMemory();
      if (!memStatus.isAvailable) {
        console.warn('[WordEngine] 内存使用率高，等待内存释放...');
        await this.fileHandler.waitForMemory();
      }

      // 使用mammoth将Word转换为HTML
      const result = await mammoth.convertToHtml({ path: filePath });
      const html = result.value;
      const messages = result.messages;

      // 同时提取纯文本
      const textResult = await mammoth.extractRawText({ path: filePath });
      const text = textResult.value;

      // 解析HTML为结构化内容
      const content = this.parseHtmlToContent(html);

      return {
        success: true,
        html,
        text,
        content,
        messages,
        metadata: await this.extractMetadata(filePath),
        fileSize,
      };
    } catch (error) {
      console.error('[WordEngine] 读取Word失败:', error);
      throw error;
    }
  }

  /**
   * 写入Word文档
   * @param {string} filePath - 文件路径
   * @param {Object} content - 文档内容
   */
  async writeWord(filePath, content) {
    try {
      console.log('[WordEngine] 写入Word文档:', filePath);

      const { title, paragraphs = [], styles = {} } = content;

      // 创建文档对象
      const sections = [];
      const children = [];

      // 添加标题
      if (title) {
        children.push(
          new Paragraph({
            text: title,
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.CENTER,
            spacing: {
              after: 400,
            },
          })
        );
      }

      // 添加段落
      for (const para of paragraphs) {
        children.push(this.createParagraph(para));
      }

      sections.push({
        properties: {},
        children,
      });

      const doc = new Document({
        creator: 'ChainlessChain',
        title: title || 'Untitled',
        description: 'Generated by ChainlessChain',
        sections,
      });

      // 生成文档buffer
      const buffer = await Packer.toBuffer(doc);

      // 检查buffer大小，使用适当的写入方法
      const bufferSize = buffer.length;
      const isLarge = bufferSize > 10 * 1024 * 1024; // 10MB

      if (isLarge) {
        console.log(`[WordEngine] 大文档 (${(bufferSize / 1024 / 1024).toFixed(2)}MB)，使用流式写入`);

        // 使用流式写入
        await this.fileHandler.writeFileStream(filePath, [buffer], {
          encoding: null // binary data
        });
      } else {
        // 小文件直接写入
        await fs.writeFile(filePath, buffer);
      }

      return {
        success: true,
        filePath,
        fileSize: bufferSize,
      };
    } catch (error) {
      console.error('[WordEngine] 写入Word失败:', error);
      throw error;
    }
  }

  /**
   * 创建段落对象
   */
  createParagraph(paraData) {
    const { text, style = {}, heading, alignment, spacing } = paraData;

    const textRuns = [];

    if (typeof text === 'string') {
      textRuns.push(
        new TextRun({
          text,
          bold: style.bold || false,
          italics: style.italic || false,
          underline: style.underline ? { type: UnderlineType.SINGLE } : undefined,
          size: style.fontSize ? style.fontSize * 2 : undefined, // Word使用半磅
          font: style.fontFamily || 'Arial',
          color: style.color,
        })
      );
    } else if (Array.isArray(text)) {
      // 支持富文本runs
      for (const run of text) {
        textRuns.push(
          new TextRun({
            text: run.text || '',
            bold: run.bold || false,
            italics: run.italic || false,
            underline: run.underline ? { type: UnderlineType.SINGLE } : undefined,
            size: run.fontSize ? run.fontSize * 2 : undefined,
            font: run.fontFamily,
            color: run.color,
          })
        );
      }
    }

    return new Paragraph({
      children: textRuns,
      heading: this.getHeadingLevel(heading),
      alignment: this.getAlignment(alignment),
      spacing: spacing || { after: 200 },
    });
  }

  /**
   * 获取标题级别
   */
  getHeadingLevel(level) {
    const levels = {
      1: HeadingLevel.HEADING_1,
      2: HeadingLevel.HEADING_2,
      3: HeadingLevel.HEADING_3,
      4: HeadingLevel.HEADING_4,
      5: HeadingLevel.HEADING_5,
      6: HeadingLevel.HEADING_6,
    };
    return levels[level];
  }

  /**
   * 获取对齐方式
   */
  getAlignment(align) {
    const alignments = {
      left: AlignmentType.LEFT,
      center: AlignmentType.CENTER,
      right: AlignmentType.RIGHT,
      justify: AlignmentType.JUSTIFIED,
    };
    return alignments[align] || AlignmentType.LEFT;
  }

  /**
   * 解析HTML为结构化内容
   */
  parseHtmlToContent(html) {
    // 简单的HTML解析，提取段落和格式
    const paragraphs = [];

    // 按行分割
    const lines = html.split('</p>');

    for (const line of lines) {
      if (!line.trim()) continue;

      // 提取文本和基本格式
      const text = line
        .replace(/<[^>]+>/g, '')
        .trim();

      if (text) {
        const para = {
          text,
          style: {},
        };

        // 检测粗体
        if (line.includes('<strong>') || line.includes('<b>')) {
          para.style.bold = true;
        }

        // 检测斜体
        if (line.includes('<em>') || line.includes('<i>')) {
          para.style.italic = true;
        }

        // 检测标题
        const headingMatch = line.match(/<h(\d)>/);
        if (headingMatch) {
          para.heading = parseInt(headingMatch[1]);
        }

        paragraphs.push(para);
      }
    }

    return { paragraphs };
  }

  /**
   * 提取元数据
   */
  async extractMetadata(filePath) {
    try {
      const stats = await fs.stat(filePath);
      return {
        fileName: path.basename(filePath),
        size: stats.size,
        created: stats.birthtime,
        modified: stats.mtime,
      };
    } catch (error) {
      return {};
    }
  }

  /**
   * Markdown转Word
   */
  async markdownToWord(markdownText, outputPath, options = {}) {
    try {
      console.log('[WordEngine] Markdown转Word');

      // 解析Markdown
      const html = marked(markdownText);
      const content = this.parseHtmlToContent(html);

      // 添加选项
      if (options.title) {
        content.title = options.title;
      }

      // 生成Word文档
      return await this.writeWord(outputPath, content);
    } catch (error) {
      console.error('[WordEngine] Markdown转Word失败:', error);
      throw error;
    }
  }

  /**
   * Word转Markdown
   */
  async wordToMarkdown(filePath) {
    try {
      console.log('[WordEngine] Word转Markdown');

      const result = await this.readWord(filePath);

      // 简单的Markdown转换
      let markdown = '';

      for (const para of result.content.paragraphs) {
        let line = para.text;

        // 处理标题
        if (para.heading) {
          line = '#'.repeat(para.heading) + ' ' + line;
        }

        // 处理粗体
        if (para.style.bold) {
          line = '**' + line + '**';
        }

        // 处理斜体
        if (para.style.italic) {
          line = '*' + line + '*';
        }

        markdown += line + '\n\n';
      }

      return {
        success: true,
        markdown,
      };
    } catch (error) {
      console.error('[WordEngine] Word转Markdown失败:', error);
      throw error;
    }
  }

  /**
   * Word转PDF
   * 注意: 需要LibreOffice或其他转换工具
   */
  async wordToPDF(filePath, outputPath) {
    try {
      console.log('[WordEngine] Word转PDF');

      // 这里需要外部工具，如LibreOffice
      // 暂时返回未实现的错误
      throw new Error('Word转PDF需要安装LibreOffice或其他转换工具');
    } catch (error) {
      console.error('[WordEngine] Word转PDF失败:', error);
      throw error;
    }
  }

  /**
   * HTML转Word
   */
  async htmlToWord(html, outputPath, options = {}) {
    try {
      console.log('[WordEngine] HTML转Word');

      const content = this.parseHtmlToContent(html);

      if (options.title) {
        content.title = options.title;
      }

      return await this.writeWord(outputPath, content);
    } catch (error) {
      console.error('[WordEngine] HTML转Word失败:', error);
      throw error;
    }
  }

  /**
   * 创建Word模板
   */
  async createTemplate(templateType, outputPath, data = {}) {
    try {
      console.log('[WordEngine] 创建Word模板:', templateType);

      const templates = {
        report: this.createReportTemplate,
        letter: this.createLetterTemplate,
        resume: this.createResumeTemplate,
      };

      const createFn = templates[templateType];
      if (!createFn) {
        throw new Error(`未知的模板类型: ${templateType}`);
      }

      const content = createFn.call(this, data);
      return await this.writeWord(outputPath, content);
    } catch (error) {
      console.error('[WordEngine] 创建模板失败:', error);
      throw error;
    }
  }

  /**
   * 创建报告模板
   */
  createReportTemplate(data) {
    const { title = '工作报告', author = '作者', date = new Date().toLocaleDateString() } = data;

    return {
      title,
      paragraphs: [
        { text: `作者: ${author}`, alignment: 'right' },
        { text: `日期: ${date}`, alignment: 'right', spacing: { after: 400 } },
        { text: '摘要', heading: 1 },
        { text: '在此输入报告摘要...', spacing: { after: 400 } },
        { text: '背景', heading: 1 },
        { text: '在此输入背景信息...', spacing: { after: 400 } },
        { text: '主要内容', heading: 1 },
        { text: '在此输入主要内容...', spacing: { after: 400 } },
        { text: '结论', heading: 1 },
        { text: '在此输入结论...', spacing: { after: 400 } },
      ],
    };
  }

  /**
   * 创建信件模板
   */
  createLetterTemplate(data) {
    const { recipient = '收件人', sender = '发件人', date = new Date().toLocaleDateString() } = data;

    return {
      paragraphs: [
        { text: date, alignment: 'right', spacing: { after: 200 } },
        { text: `尊敬的 ${recipient}:`, spacing: { after: 200 } },
        { text: '在此输入信件正文...', spacing: { after: 200 } },
        { text: '此致', spacing: { after: 100 } },
        { text: '敬礼', spacing: { after: 200 } },
        { text: sender, alignment: 'right', spacing: { after: 100 } },
        { text: date, alignment: 'right' },
      ],
    };
  }

  /**
   * 创建简历模板
   */
  createResumeTemplate(data) {
    const { name = '姓名', phone = '电话', email = '邮箱' } = data;

    return {
      title: name,
      paragraphs: [
        { text: `电话: ${phone} | 邮箱: ${email}`, alignment: 'center', spacing: { after: 400 } },
        { text: '教育背景', heading: 1 },
        { text: '在此输入教育背景...', spacing: { after: 400 } },
        { text: '工作经历', heading: 1 },
        { text: '在此输入工作经历...', spacing: { after: 400 } },
        { text: '项目经验', heading: 1 },
        { text: '在此输入项目经验...', spacing: { after: 400 } },
        { text: '技能特长', heading: 1 },
        { text: '在此输入技能特长...', spacing: { after: 400 } },
      ],
    };
  }

  /**
   * 处理项目任务（用于任务规划系统集成）
   * @param {Object} params - 任务参数
   * @returns {Promise<Object>} 执行结果
   */
  async handleProjectTask(params) {
    const { description, projectPath, llmManager, action = 'create_document' } = params;

    console.log('[WordEngine] ========== 开始处理Word文档生成任务 ==========');
    console.log('[WordEngine] 描述:', description);
    console.log('[WordEngine] 操作:', action);
    console.log('[WordEngine] 项目路径:', projectPath);

    try {
      // 使用LLM生成文档结构
      console.log('[WordEngine] 步骤1: 使用LLM生成文档结构...');
      const documentStructure = await this.generateDocumentStructureFromDescription(description, llmManager);
      console.log('[WordEngine] ✓ 文档结构已生成');
      console.log('[WordEngine]   - 标题:', documentStructure.title);
      console.log('[WordEngine]   - 段落数:', documentStructure.paragraphs?.length);

      // 生成Word文档
      const fileName = `${documentStructure.title || 'document'}.docx`;
      const filePath = path.join(projectPath, fileName);

      console.log('[WordEngine] 步骤2: 写入Word文件...');
      console.log('[WordEngine]   - 文件名:', fileName);
      console.log('[WordEngine]   - 项目路径:', projectPath);
      console.log('[WordEngine]   - 完整路径:', filePath);

      // 确保目录存在
      const dirPath = path.dirname(filePath);
      console.log('[WordEngine]   - 检查目录:', dirPath);
      try {
        await fs.mkdir(dirPath, { recursive: true });
        console.log('[WordEngine]   ✓ 目录已确保存在');
      } catch (mkdirError) {
        console.error('[WordEngine]   ✗ 创建目录失败:', mkdirError.message);
        throw new Error(`无法创建目录 ${dirPath}: ${mkdirError.message}`);
      }

      const result = await this.writeWord(filePath, documentStructure);

      console.log('[WordEngine] ✓ Word文件写入成功!');
      console.log('[WordEngine]   - 文件路径:', result.filePath);
      console.log('[WordEngine]   - 文件大小:', (result.fileSize / 1024).toFixed(2), 'KB');
      console.log('[WordEngine] ========== Word文档生成完成 ==========');

      return {
        type: 'word-document',
        success: true,
        ...result,
        title: documentStructure.title,
        paragraphCount: documentStructure.paragraphs?.length || 0
      };
    } catch (error) {
      console.error('[WordEngine] ========== 任务执行失败 ==========');
      console.error('[WordEngine] 错误:', error.message);
      console.error('[WordEngine] 堆栈:', error.stack);
      throw error;
    }
  }

  /**
   * 从描述生成Word文档结构
   * @param {string} description - 文档描述
   * @param {Object} llmManager - LLM管理器
   * @returns {Promise<Object>} 文档结构
   */
  async generateDocumentStructureFromDescription(description, llmManager) {
    const prompt = `请根据以下描述生成一份Word文档的结构（JSON格式）：

${description}

返回JSON格式：
{
  "title": "文档标题",
  "paragraphs": [
    {
      "text": "段落文本内容",
      "heading": 1,  // 可选，1-6表示标题级别
      "alignment": "left",  // left/center/right/justify
      "style": {
        "bold": false,
        "italic": false,
        "underline": false
      }
    }
  ]
}

要求：
1. title要简洁明确
2. paragraphs要包含完整的文档内容，包括标题、正文段落
3. 使用不同的heading级别组织文档结构（1级标题、2级标题等）
4. 每个段落的text要有实际的内容，不要留空或使用占位符
5. 根据段落的性质设置合适的alignment和style
6. 内容要充实、专业、符合中文写作规范

请只返回JSON，不要添加其他解释。`;

    try {
      let responseText;

      // 尝试使用本地LLM
      if (llmManager && llmManager.isInitialized) {
        console.log('[WordEngine] 使用本地LLM生成文档结构');
        const response = await llmManager.query(prompt, {
          temperature: 0.7,
          maxTokens: 3000  // Word文档需要更多token
        });
        responseText = response.text;
      } else {
        // 降级到后端AI服务
        console.log('[WordEngine] 本地LLM不可用，使用后端AI服务');
        responseText = await this.queryBackendAI(prompt);
      }

      // 提取JSON
      const jsonMatch = responseText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        const structure = JSON.parse(jsonMatch[0]);
        return this.normalizeDocumentStructure(structure, description);
      }

      // 解析失败，返回默认结构
      return this.getDefaultDocumentStructure(description);
    } catch (error) {
      console.error('[WordEngine] 生成文档结构失败:', error);
      return this.getDefaultDocumentStructure(description);
    }
  }

  /**
   * 规范化文档结构
   */
  normalizeDocumentStructure(structure, description) {
    return {
      title: structure.title || description.substring(0, 50),
      paragraphs: (structure.paragraphs || []).map(para => ({
        text: para.text || '',
        heading: para.heading,
        alignment: para.alignment || 'left',
        style: {
          bold: para.style?.bold || false,
          italic: para.style?.italic || false,
          underline: para.style?.underline || false,
          fontSize: para.style?.fontSize,
          fontFamily: para.style?.fontFamily,
          color: para.style?.color
        },
        spacing: para.spacing || { after: 200 }
      }))
    };
  }

  /**
   * 获取默认文档结构
   */
  getDefaultDocumentStructure(description) {
    return {
      title: description.substring(0, 50),
      paragraphs: [
        {
          text: '概述',
          heading: 1,
          alignment: 'left',
          spacing: { after: 300 }
        },
        {
          text: '本文档根据用户需求自动生成。主要内容如下：',
          spacing: { after: 200 }
        },
        {
          text: description,
          spacing: { after: 400 }
        },
        {
          text: '详细内容',
          heading: 1,
          spacing: { after: 300 }
        },
        {
          text: '请根据实际需求补充详细内容。',
          spacing: { after: 200 }
        }
      ]
    };
  }

  /**
   * 查询后端AI服务（降级方案）
   */
  async queryBackendAI(prompt) {
    const http = require('http');

    return new Promise((resolve, reject) => {
      const postData = JSON.stringify({
        messages: [
          { role: 'system', content: 'You are a helpful assistant. Return valid JSON only.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7
      });

      const options = {
        hostname: 'localhost',
        port: 8001,
        path: '/api/chat/stream',
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(postData)
        },
        timeout: 60000
      };

      const req = http.request(options, (res) => {
        let fullText = '';
        let buffer = '';

        res.on('data', (chunk) => {
          buffer += chunk.toString();

          // 处理SSE流
          const lines = buffer.split('\n');
          buffer = lines.pop() || '';

          for (const line of lines) {
            if (line.startsWith('data: ')) {
              try {
                const data = JSON.parse(line.slice(6));
                if (data.type === 'content' && data.content) {
                  fullText += data.content;
                } else if (data.type === 'done') {
                  resolve(fullText);
                  return;
                } else if (data.type === 'error') {
                  reject(new Error(data.error));
                  return;
                }
              } catch (e) {
                // 忽略解析错误
              }
            }
          }
        });

        res.on('end', () => {
          if (fullText) {
            resolve(fullText);
          } else {
            reject(new Error('后端AI服务未返回内容'));
          }
        });

        res.on('error', reject);
      });

      req.on('error', reject);
      req.on('timeout', () => {
        req.destroy();
        reject(new Error('后端AI服务请求超时'));
      });

      req.write(postData);
      req.end();
    });
  }
}

module.exports = new WordEngine();
